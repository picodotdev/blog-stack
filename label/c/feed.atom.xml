<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-02-21T02:03:45Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-02-21T02:03:45Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>NHibernate Avanzado: Proyecciones anidadas</title>
    <link rel="alternate" href="http://www.blogstack.info/post/koalite/2015/02/nhibernate-avanzado-proyecciones-anidadas" />
    <category term="nhibernate" />
    <category term="orm" />
    <category term="development" />
    <category term="c" />
    <author>
      <name>Juan María Hernández</name>
    </author>
    <updated>2015-02-09T05:06:33Z</updated>
    <published>2015-02-09T05:06:33Z</published>
    <content type="html">&lt;p&gt;Una de los argumentos más repetidos en contra de los ORMs es su falta de eficiencia, especialmente a la hora de hacer lecturas de grandes volúmenes de datos. En realidad, esto suele estar provocado por un mal uso del ORM e intentar cargar muchas entidades en memoria para mostrar sólo un par de datos de cada entidad, pero hay una manera fácil de solucionar esto: usar proyecciones para cargar sólo los datos que necesitamos. Todos los ORMs que conozco tienen algún sistema para construir este tipo de proyecciones, pero cuando los datos no son completamente “planos”, la cosa se complica un poco. Con NHibernate podemos generar proyecciones anidadas, es decir, en las que un objeto tiene asociada una colección de valores de una manera relativamente sencilla usando IResultTransformer. Como esto no es[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/koalite/2015/02/nhibernate-avanzado-proyecciones-anidadas"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Juan María Hernández</dc:creator>
    <dc:date>2015-02-09T05:06:33Z</dc:date>
  </entry>
  <entry>
    <title>Interpolación de cadenas en C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/11/interpolacion-de-cadenas-en-c-6" />
    <category term="novedades" />
    <category term="c-6" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-11-25T12:52:00Z</updated>
    <published>2014-11-25T12:52:00Z</published>
    <content type="html">&lt;p&gt;Seguimos con esta serie sobre las novedades de C# 6, y esta vez le toca el turno a una solicitada característica que recientemente ha entrado a formar parte de las elegidas para formar parte de esta nueva versión de nuestro lenguaje favorito: la interpolación de cadenas. Dado que aún se encuentra en desarrollo no es posible probarlo de forma sencilla, por lo que de momento tendremos que conformarnos con sacar conclusiones basándonos en la discusión de diseño en Codeplex y de la documentación existente. Avisan además que la especificación puede ser modificada, por lo que todo lo que digamos aquí aún puede variar algo, aunque mayormente será (espero) válido. En cualquier caso, el verbo interpolar se define por la RAE como “poner algo entre cosas” o “intercalar palabras o frases en el texto de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/11/interpolacion-de-cadenas-en-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-11-25T12:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Expresiones lambda en miembros de función de C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/11/expresiones-lambda-en-miembros-de-funcion-de-c-6" />
    <category term="novedades" />
    <category term="c-6" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-11-18T12:52:00Z</updated>
    <published>2014-11-18T12:52:00Z</published>
    <content type="html">&lt;p&gt;Seguimos hablando de las novedades de C# 6, y en esta ocasión nos centraremos en una interesante característica cuyo nombre, sinceramente, no estoy seguro de ser capaz de traducir de forma correcta del original “ Expression bodied function members”. Quizás sería algo así como “expresiones en cuerpo de miembros de función”, pero bueno, lo importante no es el nombre sino el concepto, así que vamos a centrarnos en él. Comencemos desde el principio. Los miembros de función son aquellos miembros de un tipo que contienen código ejecutable, como métodos, propiedades, indexadores, operadores y otros. En general, todos ellos permiten implementar su comportamiento mediante la introducción de un bloque de código, tradicionalmente enmarcado entre llaves. Pues bien, esta novedad del lenguaje permite sustituir[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/11/expresiones-lambda-en-miembros-de-funcion-de-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-11-18T12:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Declaración de variables en expresiones de C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/09/declaracion-de-variables-en-expresiones-de-c-6" />
    <category term="c-6" />
    <category term="novedades" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-11-16T18:38:38Z</updated>
    <published>2014-09-30T11:52:00Z</published>
    <content type="html">&lt;p&gt;[Actualizado 16-Nov-2014] El equipo de diseño del lenguaje C# ha decidido finalmente no incluir esta característica en la versión 6. En fin, fue bonito mientras duró :( Seguimos comentando novedades que encontraremos en la próxima versión de C#, y en esta ocasión vamos a ver una nueva característica que, sin resultar espectacular, sí nos va a proporcionar una fórmula más cómoda y concisa para resolver algunos escenarios bastante habituales. Seguro que os resulta familiar el siguiente código, más que nada porque lo habréis escrito decenas o cientos de veces: Personalmente, la introducción de parámetros out en las llamadas siempre me resulta incómodo porque me hace volver atrás para declarar una variable expresamente para la ocasión. Y hay otros casos en los que la sensación de vuelta atrás es[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/09/declaracion-de-variables-en-expresiones-de-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-09-30T11:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Mejoras en bloques try/catch de C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/10/mejoras-en-bloques-try-catch-de-c-6" />
    <category term="c-6" />
    <category term="novedades" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-10-28T12:52:01Z</updated>
    <published>2014-10-28T12:52:00Z</published>
    <content type="html">&lt;p&gt;Seguimos con la serie donde vamos desgranando las novedades de C# 6, y en esta ocasión vamos a ver algunas mejoras en el uso de bloques try/catch, a las que seguro podremos sacar buen partido. En este post trataremos dos temas distintos. En primer lugar, comentaremos la introducción del soporte de await en bloques catch/ finally, y seguiremos con la nueva capacidad de filtrado de excepciones. Vamos a ello :-) Soporte de await en bloques catch/finallyEsta nueva característica cubre una pequeña ausencia presente en las versiones anteriores del lenguaje de la que, sinceramente, no me había dado cuenta hasta la fecha. Resulta que en las versiones de C# anteriores a la 6, no estaba permitido utilizar await para esperar la finalización de una llamada asíncrona en bloques catch y finally. Por tanto,[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/10/mejoras-en-bloques-try-catch-de-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-10-28T12:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Inicialización de diccionarios en C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/10/inicializacion-de-diccionarios-en-c-6" />
    <category term="c-6" />
    <category term="novedades" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-10-21T11:48:00Z</updated>
    <published>2014-10-21T11:48:00Z</published>
    <content type="html">&lt;p&gt;En otras ocasiones hemos hablado de novedades que acompañarán a la próxima revisión de C# que nos ahorraban algo de tiempo y pulsaciones de tecla a la hora de codificar algunos escenarios bastante frecuentes, a la vez que mejoraban la legibilidad. Pues en esa misma línea, vemos ahora una nueva forma de inicializar colecciones clave-valor, como son los diccionarios. Ciertamente es un cambio bastante pequeño, de los que fácilmente podrían pasar desapercibidos junto a otras novedades de mayor peso, pero creo que también vale la pena conocerlo. Para ponernos en situación, echemos un vistazo al siguiente código, totalmente válido en las versiones actuales de C#: El código anterior es bastante limpio y pocas pegas se le podría poner, salvo que a primera vista no queda claro en absoluto qué tipo de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/10/inicializacion-de-diccionarios-en-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-10-21T11:48:00Z</dc:date>
  </entry>
  <entry>
    <title>Rendimiento de nameof en C# 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2014/10/rendimiento-de-nameof-en-c-6" />
    <category term="c-6" />
    <category term="novedades" />
    <category term="c" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2014-10-16T11:45:01Z</updated>
    <published>2014-10-16T11:45:00Z</published>
    <content type="html">&lt;p&gt;Hace unos días mostrábamos por aquí el nuevo operador nameof que acompañará a C# 6, y cuya función, resumidamente, es obtener el nombre a nivel de código de la variable o miembro a la que se aplica: En los comentarios de este post, el amigo Kiquenet se preguntaba qué incidencia podía tener el uso de este operador en el rendimiento de nuestras aplicaciones, y esa duda es la que vamos a responder muy rápidamente ahora. Se podía intuir que la incidencia sería cero porque la resolución del nombre tenía toda la pinta de ser realizada en tiempo de compilación y, por tanto, los usos del operador nameof serían transformados en una constantes de cadena, pero la verdad es que siempre quedaba la duda de si había algún tipo de “magia” adicional por detrás. Por esta razón, he realizado una prueba muy sencilla.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2014/10/rendimiento-de-nameof-en-c-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2014-10-16T11:45:00Z</dc:date>
  </entry>
</feed>

