<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-11-08T18:02:15Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-11-08T18:02:15Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Java para tareas de scripting</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-08T17:00:00Z</updated>
    <published>2015-11-07T14:00:00Z</published>
    <content type="html">&lt;p&gt;Para programar pequeños scripts normalmente se suele emplear el intérprete de comandos en GNU/Linux bash o si es algo complejo un lenguaje interpretado como Python, Ruby o Groovy. Pero no pienses que Java no puede ser empleado para tareas de scripting, en este artículo muestro que problemas presentan los lenguajes interpretados o dinámicos, que ventajas tiene usar Java y finalmente como usarlo con la misma sencillez que un lenguaje interpretado para el nicho funcional de los scripts. Java puede emplearse para cualquier propósito desde aplicaciones web en la parte servidora, aplicaciones de escritorio como escribí en dos artículos introductorios sobre JavaFX, juegos con alta calidad gráfica incluso para dispositivos de capacidades más reducidas como IoT o embebidos y verdaderamente limitados.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-11-07T14:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Java Mockito y los Mock Object</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/10/java-mockito-y-los-mock-object" />
    <category term="java" />
    <category term="javatips" />
    <category term="frameworksjava" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-10-30T15:51:42Z</updated>
    <published>2015-10-30T15:51:42Z</published>
    <content type="html">&lt;p&gt;Java Mockito es uno de los frameworks de Mock más utilizados en la plataforma Java. Esto es debido a la gran facilidad de uso que tiene. Vamos a intentar explicar el concepto de Mock y como funciona Java Mockito , para ello construiremos unos test sencillos partiendo de dos clases de Servicio que se encuentran […] La entrada Java Mockito y los Mock Object aparece primero en Arquitectura Java.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/10/java-mockito-y-los-mock-object"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-10-30T15:51:42Z</dc:date>
  </entry>
  <entry>
    <title>Múltiples esquemas o bases de datos con jOOQ y Spring en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java" />
    <category term="blog-stack" />
    <category term="programcion" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-27T17:00:00Z</updated>
    <published>2015-10-27T17:00:00Z</published>
    <content type="html">&lt;p&gt;Aún en las aplicaciones monolíticas que comparten una única base de datos tratamos de dividirla en varios servicios que manejen cierto nicho de información con la intención de que un cambio en una parte sea transparente para las otras partes. Cada servicio de la aplicación monolítica podría potencialmente convertirse en un microservicio y en este caso para que cada micoservicio tenga un ciclo de vida independiente compartir la base de datos es algo a evitar. Incluso en las aplicaciones monolíticas podemos querer guardar cada nicho de información en su propio esquema para evitar acoplamiento entre las diferentes partes o también como forma de tener varios servidores de bases de datos y escalar la aplicación en cierta forma. En estos casos necesitaremos que la aplicación acceda a varios esquemas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-27T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>El patrón de diseño Observer y una forma de implementarlo en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-26T21:00:00Z</updated>
    <published>2015-10-24T10:00:00Z</published>
    <content type="html">&lt;p&gt;Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón Observer. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón Observer nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga. En Java este patrón podemos implementarlo usando una clase, la clase Observable, y una interfaz, la interfaz Observer proporcionadas en el propio JDK. La clase que queremos que reciba los eventos deberá implementar la interfaz Observer y el objeto que queremos que produzca los eventos debe extender o contener una propiedad de tipo Observable. La interfaz Observer contiene[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-24T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo del patrón de diseño Observer y una forma de implementarlo en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/ejemplo-del-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-24T21:00:00Z</updated>
    <published>2015-10-24T10:00:00Z</published>
    <content type="html">&lt;p&gt;Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón Observer. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón Observer nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga. En Java este patrón podemos implementarlo usando una clase, la clase Observable, y una interfaz, la interfaz Observer proporcionadas en el propio JDK. La clase que queremos que reciba los eventos deberá implementar la interfaz Observer y el objeto que queremos que produzca los eventos debe extender o contener una propiedad de tipo Observable. La interfaz Observer contiene[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/ejemplo-del-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-24T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>El concepto de Java Collections Views</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/10/el-concepto-de-java-collections-views" />
    <category term="javaapi" />
    <category term="java-basico" />
    <category term="javacore" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-10-23T15:46:27Z</updated>
    <published>2015-10-23T15:46:27Z</published>
    <content type="html">&lt;p&gt;Java Collections Views es uno de los conceptos que más suele sorprender  a los programadores cuando comienzan a trabajar con el framework de colecciones de Java. Imaginemonos que disponemos del siguiente Array de Strings en Java. En muchas ocasiones querremos convertir al Array de Strings en un List de Strings. Esta operación es muy sencilla y […] La entrada El concepto de Java Collections Views aparece primero en Arquitectura Java.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/10/el-concepto-de-java-collections-views"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-10-23T15:46:27Z</dc:date>
  </entry>
  <entry>
    <title>Cómo crear clases factoría sin usar if-else</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-19T17:00:00Z</updated>
    <published>2015-10-18T10:00:00Z</published>
    <content type="html">&lt;p&gt;En el artículo cómo crear clases factoría sin usar if-else se comentan varias formas para conseguirlo. Las soluciones que se proponen son usar: Reflection: sin embargo esta solución obliga a que el cliente de la factoría conozca el nombre completo de la clase a crear incluyendo el paquete en el que está y hace que la factoría no abstraiga al cliente de conocerlo que puede ser uno de sus objetivos. Además el parámetro es un String con lo que en los refactors el compilador no nos ayudará, el compilador es una de mis 10 razones para seguir usando Java. Map: en esta solución se asocia una clave (en String) con la clase que devuelve la factoría. Igualmente usar un String como clave es algo a evitar ya que es propenso a errores al no tener ayuda del compilador en los valores de los Strings si estas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-18T10:00:00Z</dc:date>
  </entry>
</feed>

