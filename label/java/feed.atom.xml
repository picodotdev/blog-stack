<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-03-20T21:02:31Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-03-20T21:02:31Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Introducción y ejemplo de API RPC con Apache Thrift</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/introduccion-y-ejemplo-de-api-rpc-con-apache-thrift" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-20T21:00:00Z</updated>
    <published>2015-03-20T16:03:18Z</published>
    <content type="html">&lt;p&gt;Las aplicaciones están pasando de ser elementos aislados, grandes y monolíticos a ser desarrolladas como varios microservicios que colaboran entre si para en conjunto ofrecer la funcionalidad deseada. Aunque los microservicios presentan sus propias problemáticas resuelven algunas que poseen los sistemas monolíticos, entre algunas de sus caracteríticas deseables están: mayor cohesión, menor acoplamiento, menor tamaño, mayor independencia de la tecnología usando la más adecuada en cada situación, más fácilmente reemplazables y despliegues más sencillos. También, la funcionalidad ofrecida por una aplicación puede quererse consumirse desde otra aplicación surgiendo de esta forma una API. Para ofrecer una API de una aplicación que pueda consumirse internamente, desde diferentes dispositivos o por[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/introduccion-y-ejemplo-de-api-rpc-con-apache-thrift"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-20T16:03:18Z</dc:date>
  </entry>
  <entry>
    <title>Aplicación web Java autocontenida con Tomcat Embedded</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-18T21:00:00Z</updated>
    <published>2015-03-14T09:32:20Z</published>
    <content type="html">&lt;p&gt;La tendencia de las aplicaciones es que sean construidas como múltiples servicios pequeños que colaboran entre si en vez de consistir en una aplicación grande desplegada en un servidor de aplicaciones. La aparición de nuevas tecnologías como Docker facilitan la construcción y despliegue de los microservicios. Los microservicios con su máxima de bajo acoplamiento y alta cohesión tratan de incluir todo lo necesario para funcionar evitando las dependencias de cualquier tipo de elemento fuera de su ámbito no incluyendo el uso de otros servicios. Con Docker es posible desplegarlos en cualquier máquina que disponga del servicio, esto evita problemas de configuración al pasar la aplicación de un entorno de desarrollo a uno de producción ya que las características del entorno de desarrollo y el de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-14T09:32:20Z</dc:date>
  </entry>
  <entry>
    <title>Datos de sesión externalizados con Spring Session</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/datos-de-sesion-externalizados-con-spring-session" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-08T02:30:00Z</updated>
    <published>2015-03-07T08:05:06Z</published>
    <content type="html">&lt;p&gt;Por defecto los datos de la sesión de una aplicación web Java se guardan en el servidor de aplicaciones y en memoria, esto produce que al reiniciar el servidor por un despliegue los datos de la sesión se pierdan y provoque en los usuarios alguna molestia como tener que volver a iniciar sesión. En Tomcat existe la posibilidad de que los datos de las sesiones sean persistidas en disco con la opción saveOnRestart del elemento de configuración Manager que evita que los datos de las sesiones se pierdan en los reinicios, al menos para los servicios formados por una única instancia. Para evitar que los usuarios perciban los reinicios o caídas del servidor hay varias soluciones algunas tratando de diferentes formas externalizar las sesiones del servidor de aplicaciones. Con estas soluciones se pueden[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/datos-de-sesion-externalizados-con-spring-session"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-07T08:05:06Z</dc:date>
  </entry>
  <entry>
    <title>Gestión de ficheros con  Java nio Path</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/03/gestion-de-ficheros-con-java-nio-path" />
    <category term="java-basico" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-03-06T10:25:22Z</updated>
    <published>2015-03-06T10:25:22Z</published>
    <content type="html">&lt;p&gt;Hemos usado durante muchos años java.io para trabajar con ficheros en el mundo Java . Se trata de un API muy potente y flexible que nos permite realizar casi cualquier tipo de operación. Sin embargo es un API complicada de entender. Java NIO (Not Blocking IO) es un nuevo API disponible desde Java7 que nos permite mejorar el rendimiento así como simplificar el manejo de muchas cosas. Vamos a ver un ejemplo apoyándonos en  FileSystem y Path de este nuevo API.   El concepto de FileSystem define un sistema de ficheros completo. Mientras que por otro lado el concepto de Path hace referencia a un directorio, fichero o link que tengamos dentro de nuestro sistema de ficheros. El siguiente código hace uso de FileSystem y Path para obtener el nombre de un fichero así como la carpeta padre en la que se[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/03/gestion-de-ficheros-con-java-nio-path"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-03-06T10:25:22Z</dc:date>
  </entry>
  <entry>
    <title>Java y  fluid interface</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/03/java-y-fluid-interface" />
    <category term="java-basico" />
    <category term="java-conceptos" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-03-03T12:39:00Z</updated>
    <published>2015-03-03T12:39:00Z</published>
    <content type="html">&lt;p&gt;Trabajamos todos los días con Java y uno de las cosas que uno echa de menos a veces es que existan más interfaces fluidas a nivel del lenguaje. ¿Qué es una fluid interface? . Son interfaces o clases que cuando invocamos a un método concreto nos devuelve el mismo objeto modificado . De tal forma que podemos volver a solicitar otro método del mismo objeto y  encadenar más operaciones.   Fluid interfaces y StringBuilder Una de las clases más habituales a la hora de usar programación fluida es StringBuffer vamos a ver un ejemplo sencillo. 
package com.arquitecturajava;

public class Principal {

 public static void main(String[] args) {

 StringBuilder cadena = new StringBuilder("?hola");
 cadena.delete(0, 1).append(" que tal?").insert(4, " amigo ");
 System.out.println("Mensaje: " + cadena);

[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/03/java-y-fluid-interface"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-03-03T12:39:00Z</dc:date>
  </entry>
  <entry>
    <title>Listener de eventos de Hibernate con servicios de Spring</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/02/listener-de-eventos-de-hibernate-con-servicios-de-spring" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-02-28T09:59:08Z</updated>
    <published>2015-02-28T09:59:08Z</published>
    <content type="html">&lt;p&gt;En el anterior artículo explicaba como crear un listener que reciba eventos de Hibernate pero quizá necesitemos en el listener hacer uso de un servicio de Spring si el proceso de la acción necesita aprovecharse de la funcionalidad proporcionada en los servicios. En este artículo mostraré como crear un listener de Hibernate que use un servicio de Spring, es decir, un listener de Hibernate con la posibilidad de inyectar servicios de Spring. Para hacer la integración de los listeners con Spring debemos sustituir el Interceptor por un servicio que haga lo mismo pero al inicio del contenedor de Spring con la anotación @PostConstruct. Para ello creamos una clase con el siguiente contenido: package es.com.blogspot.elblogdepicodev.plugintapestry.services.hibernate;

import javax.annotation.PostConstruct;

import[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/02/listener-de-eventos-de-hibernate-con-servicios-de-spring"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-02-28T09:59:08Z</dc:date>
  </entry>
  <entry>
    <title>Colecciones y Google Guava</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/02/colecciones-y-google-guava" />
    <category term="java-basico" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-02-27T10:24:27Z</updated>
    <published>2015-02-27T10:24:27Z</published>
    <content type="html">&lt;p&gt;En algunas ocasiones echamos en falta que el framework de colecciones de Java sea más amplio y contenga un conjunto de clases más flexible. Este problema le podemos solventar apoyandonos en Google Guava un conjunto de librerías de de Google que nos aportan mucha funcionalidad extra. Entre estas funcionalidades destacan nuevos tipos de colecciones, vamos a hacer unos ejemplos. El concepto de MultiSet (Bolsa) Java soporta el concepto de Set que es un grupo de elementos no repetidos . Guava soporta el concepto de MultiSet que es un conjunto de elementos que esta compuesto de elementos repetidos de los cuales podemos obtener un conjunto clásico sin repeticiones   Vamos a ver un ejemplo sencillo en código: 

package com.arquitecturajava;

import java.util.Set;

import com.google.common.collect.HashMultiset;
import[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/02/colecciones-y-google-guava"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-02-27T10:24:27Z</dc:date>
  </entry>
</feed>

