<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-05-29T20:02:17Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-05-29T20:02:17Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Alternativa a Hibernate u ORM y ejemplo de jOOQ</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq" />
    <category term="blog-stack" />
    <category term="programacion" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-05-29T18:00:00Z</updated>
    <published>2015-05-29T18:00:00Z</published>
    <content type="html">&lt;p&gt;Los ORMs nos han facilitado el acceso a los datos de una base de datos relacional. Han solucionado algunos problemas y facilitado el acceso a los datos pero traído consigo otros nuevos como el problema N+1 o la perdida de control del modelo relacional. jOOQ forma parte de una nueva generación de herramientas que puede sustituir a otras como Hibernate. Y después de haberlo usado puede ser cierto. Con el auge de los lenguajes de programación orientados a objetos han surgido varias herramientas que intentan hacer que el trabajo de unir el mundo orientado a objetos del lenguaje que empleemos y el modelo relacional de las bases de datos sea más transparente, estas herramientas son conocidas como Object Realtiomal Mapping (ORM). Una de las más conocidas y usada en la plataforma Java es Hibernate.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/05/alternativa-a-hibernate-u-orm-y-ejemplo-de-jooq"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-05-29T18:00:00Z</dc:date>
  </entry>
  <entry>
    <title>10 razones para seguir usando Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/05/1-razones-para-seguir-usando-java" />
    <category term="opinion" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-05-22T15:00:00Z</updated>
    <published>2015-05-22T15:00:00Z</published>
    <content type="html">&lt;p&gt;El sábado 23 de mayo de 2015 el lenguaje Java cumple 20 años de historia y aún hoy Java sigue siendo uno de los lenguajes de programación preferidos para desarrollar en un mundo tecnológico en el que unos pocos años pueden darse grandes cambios y en dos décadas ver surgir nuevas tecnologías y verlas languidecer. Algunas personas se jactan y hablan con un tono de desprecio y mofa nada agradable hacia Java mostrando su desconocimiento o prejuicios siguiendo algunos tópicos bastante difundidos la mayoría incorrectos. A otras personas quizá no les gusta Java no tanto por el lenguaje como por los proyectos que ha desarrollado en él, en consultoras cárnicas, para clientes con condiciones laborales paupérrimas, con tecnologías, librerías y frameworks obsoletos o códigos heredados programados por programadores[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/05/1-razones-para-seguir-usando-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-05-22T15:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Java Collections Performance</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/05/java-collections-performance" />
    <category term="java-tuning" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-05-20T10:28:42Z</updated>
    <published>2015-05-20T10:28:42Z</published>
    <content type="html">&lt;p&gt;Un tema muy recurrente cuando hablamos de rendimiento es el de Java Collections Performance. Todos usamos el framework de collecciones pero muchas veces nos olvidamos de su rendimiento. ¿Cual es la colección más rápida a la hora de buscar elementos?. Vamos a verlo con un ejemplo sencillo.  Para ello partiremos de tres colecciones diferentes, un ArrayList,un HashSet y un TreeSet. Todos ellos soportan el interface Collection y podemos buscar un elemento a través del método contains().   Hay que recordar que un ArrayList almacena la información en formato lista. Un HashSet lo almacena como un bloque de claves hash y cada una dispone de su propia sublista. Por último un TreeSet almacena un conjunto en forma de árbol binario. Vamos a usar la clase System y su método nanoTime para obtener los tiempos[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/05/java-collections-performance"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-05-20T10:28:42Z</dc:date>
  </entry>
  <entry>
    <title>Programación de juegos y 3D en Java con jMonkeyEngine</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/05/programacion-de-juegos-y-3d-en-java-con-jmonkeyengine" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-05-09T13:30:00Z</updated>
    <published>2015-05-09T08:18:40Z</published>
    <content type="html">&lt;p&gt;Erróneamente se sigue pensado que Java es un lenguaje lento en ejecución, en las primeras versiones era cierto pero hoy la realidad es que con las mejoras introducidas en cada versión de Java y la máquina virtual el rendimiento actual es comparable a C y C++. En la programación de juegos y 3D gran parte del proceso de representación gráfica se ha descargado de la CPU a las cada vez más potentes tarjetas gráficas, la potencia de estas GPU son las que determinan la capacidad de proceso gráfico y la calidad gráfica de los juegos. Java no suele ser considerado como opción para programar videojuegos triple AAA pero ahí está Minecraft uno de los juegos más populares y un ejemplo de que un juego de buena calidad y rendimiento también se puede hacer en Java. Hay algunos otros ejemplos notables como[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/05/programacion-de-juegos-y-3d-en-java-con-jmonkeyengine"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-05-09T08:18:40Z</dc:date>
  </entry>
  <entry>
    <title>Entendiendo el uso de Java System Class</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/05/entendiendo-el-uso-de-java-system-class" />
    <category term="java-basico" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-05-08T07:41:29Z</updated>
    <published>2015-05-08T07:41:29Z</published>
    <content type="html">&lt;p&gt;El uso de Java System Class es algo de utilizamos todos , normalmente invocando System.out.println(“hola”) o algo muy similar. Estamos muy acostumbrados a usar esta clase , pero muchas veces no entendemos a detalle que operaciones  realiza. La clase System pertenece al package java.lang y dispone de varias variables estáticas a utilizar. Estas variables son in, out y err que hacen referencia a la entrada ,salida y manejo de errores respectivamente. De ahí que podamos invocar sin problema 

System.out.println("hola");

 Ya que estaremos usando la variable estática “out” de la clase System para invocar a su método println(). Métodos de Java System Class La clase System tiene otros métodos muy útiles ya que es la encargada de interactuar en el sistema. Por ejemplo nos permite acceder a la propiedad[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/05/entendiendo-el-uso-de-java-system-class"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-05-08T07:41:29Z</dc:date>
  </entry>
  <entry>
    <title>Escribir en varios «Writer» a la vez</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/04/escribir-en-varios-writer-a-la-vez" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-04-30T18:00:47Z</updated>
    <published>2015-04-30T18:00:47Z</published>
    <content type="html">&lt;p&gt;Hace un tiempo tuve necesidad de generar cierto contenido sobre varios writers, la necesidad en concreto era generar un archivo xml en disco y al mismo tiempo el mismo contenido para un correo electrónico. Para no escribir lo mismo en dos Writer diferentes la solución fue crear un writer y este fuese el que escribiese el contenido que se le enviaba sobre varios writers. En la API de Java no hay una clase específica que haga esto pero es muy sencillo hacer una implementación que lo haga, esto va a ser lo que explicaré en el siguiente artículo. Para hacer que el contenido de un writer se escriba a varios deberemos extender la clase Writer de esta manera su uso será como la de cualquier otro Writer. Lo especial de la implementación del writer es que su misión será realizar la misma operación que[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/04/escribir-en-varios-writer-a-la-vez"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-04-30T18:00:47Z</dc:date>
  </entry>
  <entry>
    <title>Utilizando Java Custom Generics</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/04/utilizando-java-custom-generics" />
    <category term="java-basico" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-04-28T08:39:00Z</updated>
    <published>2015-04-28T08:39:00Z</published>
    <content type="html">&lt;p&gt;En muchas ocasiones cuando utilizamos Java Generics nos es suficiente con utilizar el framework de Colecciones (ArrayList,HashSet etc)  para solventar nuestros problemas . Sin embargo en algunos casos esto no es posible ya que ninguno de los elementos encajan con lo que estamos buscando. En estos casos debemos construir un Java Custom Generics que se encargue de solventar el problema al que nos enfrentamos. Un ejemplo clásico de esto es el concepto de Nodo. Este concepto es conocido por todos ya que HTML lo usa a traves de su famoso DOM (Document Object Model). Recordemos que un Nodo es un elemento que esta relacionado con otro elemento de su mismo tipo de forma jerárquica.   Nodos y Java Custom Generics Vamos a ver como construimos una clase genérica que gestione el concepto de Nodo. 
package[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/04/utilizando-java-custom-generics"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-04-28T08:39:00Z</dc:date>
  </entry>
</feed>

