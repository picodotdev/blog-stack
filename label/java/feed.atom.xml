<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-09-22T08:02:24Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-09-22T08:02:24Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>El concepto de  Java Proxy Pattern</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/09/el-concepto-de-java-proxy-pattern" />
    <category term="java" />
    <category term="design-patterns" />
    <category term="arquitectura" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-09-22T07:20:19Z</updated>
    <published>2015-09-22T07:20:19Z</published>
    <content type="html">&lt;p&gt;Java Proxy Pattern es uno de los patrones de diseño que más se usa en Java. Lamentablemente a veces es difícil de entender como funciona y sobre todo de en que frameworks se utiliza para solventar los diferentes problemas del desarrollo de aplicaciones.¿ Qué es exactamente un Proxy? .Vamos a intentar explicarlo de forma breve. […] La entrada El concepto de Java Proxy Pattern aparece primero en Arquitectura Java.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/09/el-concepto-de-java-proxy-pattern"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-09-22T07:20:19Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo de multiproyecto con Gradle</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-09-15T17:00:00Z</updated>
    <published>2015-09-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;En un proyecto grande podemos tener necesidad de dividir el monolito al menos en varios módulos y yendo un paso más lejos en microservicios. La herramienta de construcción que usemos deberá de facilitarnos automatizar la tarea de construcción del código fuente de cada módulo individual, de todos a la vez o de los microservicios si tienen alguna dependencia compartida. En el artículo y ejemplo explicaré cómo usando Gradle podemos dividir el proyecto en varios módulos. No deja de ser un ejemplo pero es bastante completo y está formado por dos aplicaciones web, una librería de componentes y otra librería con el modelo de persistencia, usa Spring, jOOQ, Tapestry, PostgreSQL, Docker, Liquibase, … Cuando una aplicación o proyecto crece en algún momento podemos tener necesidad de partir el monolito[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-15T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo práctico de ServiceLoader con ServiceProvider de Java Money</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-practico-de-serviceloader-con-serviceprovider-de-java-money" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-09-13T09:00:00Z</updated>
    <published>2015-09-13T09:00:00Z</published>
    <content type="html">&lt;p&gt;Una aplicación que trabaje con importes y diferentes divisas necesitará ratios de conversión, estos ratios de conversión deberemos obtenerlos de algún servicio. Con la API de Java Money que aun en Java 8 no está incorporada en el JDK aunque si como una librería podremos trabajar de forma cómoda con importes, divisas y ratios. En este artículo explicaré un ejemplo de uso práctico de la clase ServiceLoader y como obtener ratios del servicio Open Exchange Rates. La semana pasada comentaba la clase ServiceLoader disponibles en el JDK y como nos puede servir para que nuestra aplicación o API sea extensible en futuras versiones o para alguien que quiera adaptarla a sus necesidades. La clase ServiceLoader es el método que se emplea en la API de Java para tratamiento de divisas, importes y conversiones[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-practico-de-serviceloader-con-serviceprovider-de-java-money"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-13T09:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Aplicación Java extensible con la clase ServiceLoader</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-09-12T08:00:00Z</updated>
    <published>2015-09-12T08:00:00Z</published>
    <content type="html">&lt;p&gt;Java ofrece un mecanismo incluido en el propio JDK para hacer las aplicaciones extensibles o ampliables en un momento posterior al de desarrollo. La clase ServiceLoader permite obtener las implementaciones definidas en el classpath de una determinada interfaz. En este artículo explico esta clase y muestro un ejemplo sencillo de como usarla. Puede que al desarrollar una aplicación necesitamos que esta sea extensible, esto significa que en el momento de desarrollo no conocemos las implementaciones de un determinado servicio que se proporcionarán en un futuro. Un servicio no es más que la implementación de una determinada interfaz que definimos en el momento de desarrollo. Java con la clase ServiceLoader proporciona un mecanismo estándar e incorporado en el JDK para cargar servicios con alguna[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-12T08:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Patrón Singleton</title>
    <link rel="alternate" href="http://www.blogstack.info/post/codecriticon/2015/09/patron-singleton" />
    <category term="programacion" />
    <category term="patrones-de-diseno" />
    <category term="java" />
    <category term="singleton" />
    <author>
      <name>Antonio</name>
    </author>
    <updated>2015-09-08T22:28:22Z</updated>
    <published>2015-09-08T22:28:22Z</published>
    <content type="html">&lt;p&gt;El patrón Singleton forma parte de los patrones creacionales. Se trata de uno de los patrones más usados y conocidos por los desarrolladores, y también es uno de los patrones más controvertidos. El patrón Singleton se encarga de controlar que únicamente se crea una instancia de una clase en toda la aplicación mediante el uso de un único punto de acceso. La definición que se da en el libro “Design Patterns: Elements of Reusable Object-Oriented Software” es: “Garantiza que una clase sólo tenga una instancia y proporciona un punto de acceso global a ella.” El diagrama de definición del patrón Singleton es simple: Sólo se proporciona un punto de acceso para crear una instancia de una clase Singleton. El constructor es privado y se proporciona un método getInstance() que se encarga de proporcionar[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/codecriticon/2015/09/patron-singleton"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Antonio</dc:creator>
    <dc:date>2015-09-08T22:28:22Z</dc:date>
  </entry>
  <entry>
    <title>Java Generics Erasure y sus problemas</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/08/java-generics-erasure-y-sus-problemas" />
    <category term="java-core" />
    <category term="java-basico" />
    <category term="java-tips" />
    <category term="java" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-08-26T06:58:45Z</updated>
    <published>2015-08-26T06:58:45Z</published>
    <content type="html">&lt;p&gt;El trabajo con los tipos Genéricos en Java es algo de lo más habitual , pero siempre hay situaciones en las que aparecen dudas. Una de las cosas más importantes que hay que entender hablando de Genéricos es que se trata realmente de “sintaxis sugar” es decir no existen realmente en la JVM. Esto es debido a que en su momento se llego a la conclusión que implementarlos directamente en la máquina virtual era muy costoso. Vamos a ver un ejemplo usando el concepto de Java Generics Erasure, supongamos que tenemos el siguiente código: 
package com.arquitecturajava.generics;

import java.util.List;

public class GestorListas {

 public void imprimirLista(List&lt;Persona&gt; listaPersonas) {

 for (Persona p: listaPersonas) {
 System.out.println(p);
 }

 }

 public void imprimirLista(List&lt;Factura&gt; listaFacturas)[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/08/java-generics-erasure-y-sus-problemas"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-08-26T06:58:45Z</dc:date>
  </entry>
  <entry>
    <title>Utilizando Java Singleton Properties</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/08/utilizando-java-singleton-properties" />
    <category term="java-tips" />
    <category term="java" />
    <category term="design-patterns" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-08-21T09:52:00Z</updated>
    <published>2015-08-21T09:52:00Z</published>
    <content type="html">&lt;p&gt;El patrón Singleton es uno de los más utilizados y se encarga de construir una clase de la cual únicamente se pueda construir un objeto. La construcción el patrón no es complicada pero a la gente que empieza le cuesta hacerse una idea de cual pueden ser sus usos. Muchas veces no parece tener mucho sentido crear una clase que solo pueda tener un objeto. Java Singleton Properties Vamos a usar un fichero de Properties para clarificar el concepto. Recordemos que un fichero de Properties es un fichero Java que contiene clases/valores. En este caso contendrá los parámetros de conexión a una base de datos. url=localhost usuario=root password=123456 Este fichero puede ser leído desde Java y acceder la información que contiene utilizando la clase Properties de java.util. 

package com.arquitecturajava.singleton;

import[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/08/utilizando-java-singleton-properties"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-08-21T09:52:00Z</dc:date>
  </entry>
</feed>

