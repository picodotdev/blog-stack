<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-11-10T19:02:41Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-11-10T19:02:41Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Java para tareas de «scripting»</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:01:00Z</updated>
    <published>2015-11-07T14:00:00Z</published>
    <content type="html">&lt;p&gt;Para programar pequeños scripts normalmente se suele emplear el intérprete de comandos en GNU/Linux bash o si es algo complejo un lenguaje interpretado como Python, Ruby o Groovy. Pero no pienses que Java no puede ser empleado para tareas de scripting, en este artículo muestro que problemas presentan los lenguajes interpretados o dinámicos, que ventajas tiene usar Java y finalmente como usarlo con la misma sencillez que un lenguaje interpretado para el nicho funcional de los scripts. Java puede emplearse para cualquier propósito desde aplicaciones web en la parte servidora, aplicaciones de escritorio como escribí en dos artículos introductorios sobre JavaFX, juegos con alta calidad gráfica incluso para dispositivos de capacidades más reducidas como IoT o embebidos y verdaderamente limitados.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-11-07T14:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Múltiples esquemas o bases de datos con jOOQ y Spring en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java" />
    <category term="blog-stack" />
    <category term="programcion" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-10-27T17:00:00Z</published>
    <content type="html">&lt;p&gt;Aún en las aplicaciones monolíticas que comparten una única base de datos tratamos de dividirla en varios servicios que manejen cierto nicho de información con la intención de que un cambio en una parte sea transparente para las otras partes. Cada servicio de la aplicación monolítica podría potencialmente convertirse en un microservicio y en este caso para que cada micoservicio tenga un ciclo de vida independiente compartir la base de datos es algo a evitar. Incluso en las aplicaciones monolíticas podemos querer guardar cada nicho de información en su propio esquema para evitar acoplamiento entre las diferentes partes o también como forma de tener varios servidores de bases de datos y escalar la aplicación en cierta forma. En estos casos necesitaremos que la aplicación acceda a varios esquemas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-27T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>El patrón de diseño Observer y una forma de implementarlo en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-10-24T10:00:00Z</published>
    <content type="html">&lt;p&gt;Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón Observer. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón Observer nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga. En Java este patrón podemos implementarlo usando una clase, la clase Observable, y una interfaz, la interfaz Observer proporcionadas en el propio JDK. La clase que queremos que reciba los eventos deberá implementar la interfaz Observer y el objeto que queremos que produzca los eventos debe extender o contener una propiedad de tipo Observable. La interfaz Observer contiene[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-24T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>JavaFX Scene Builder, editor para crear archivos FXML</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-10-08T22:00:00Z</published>
    <content type="html">&lt;p&gt;Con la aplicación JavaFX Scene Builder podemos construir la interfaz gráfica de una aplicación de escritorio Java de forma más sencilla. JavaFX Scene Builder genera archivos descriptores FXML que podemos cargar en la aplicación evitando la tediosa y no sencilla tarea de construir la interfaz gráfica mediante código. En el artículo comento la aplicación JavaFX Scene Builder, como usar los archivos FXML en una aplicación de escritorio, como asociar manejadores de eventos y como cambiar las propiedades de los controles. Por lo poco que he visto JavaFX es una gran evolución sobre AWT y Swing para desarrollar aplicaciones de escritorio en Java aportando varias mejoras. En el artículo Introducción a JavaFX comentaba que una de las cosas que me parecía más complicada usando tanto AWT y más tarde usando[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-08T22:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Introducción a JavaFX, aplicaciones de escritorio en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-10-02T17:00:00Z</published>
    <content type="html">&lt;p&gt;Java tiene una fuerte presencia en el ámbito de desarrollo para aplicaciones web, más recientemente ha sido empleado por la plataforma Android. En la misma medida que han crecido las aplicaciones web y móviles nativas las aplicaciones de escritorio han perdido presencia, sin embargo, para ciertos casos son la opción adecuada. Con la aparición de JavaFX aportando varias mejoras sobre Swing o AWT en la plataforma Java se pueden desarrollar aplicaciones de escritorio multiplataforma «ricas». Podemos empezar por el ejemplo Hola Mundo de JavaFX de este artículo. El lenguaje de programación Java es ampliamente usado en el ámbito empresarial destacando la programación de aplicaciones web. Las aplicaciones web se han extendido tanto por su fácil despliegue a los clientes (un navegador basta), un desarrollo[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-02T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo del patrón de diseño Builder</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-del-patron-de-diseno-builder" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-09-27T10:00:00Z</published>
    <content type="html">&lt;p&gt;Construir objetos es una tarea básica en los lenguajes orientados a objetos. En Java, las instancias de una clase se crean con la palabra clave reservada new y un método especial llamado constructor. Al diseñar una clase debemos tener algunas cuestiones para evitar varios constructores telescópicos, evitar constructores que son combinación de varios argumentos opcionales y permitir obtener instancias de objetos con estado válido. Si se nos presentan estas situaciones podemos usar el patrón de diseño Builder que consiste en básicamente en una clase especializada en construir instancias de otra clase que podemos hacer usable con una API fluida y alguna cosa más deseable que explico en el artículo. Al escribir los métodos constructores de instancias de una clase puede ocurrirnos que algunos de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-del-patron-de-diseno-builder"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-27T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo de multiproyecto con Gradle</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="tapestry" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-10T18:00:00Z</updated>
    <published>2015-09-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;En un proyecto grande podemos tener necesidad de dividir el monolito al menos en varios módulos y yendo un paso más lejos en microservicios. La herramienta de construcción que usemos deberá de facilitarnos automatizar la tarea de construcción del código fuente de cada módulo individual, de todos a la vez o de los microservicios si tienen alguna dependencia compartida. En el artículo y ejemplo explicaré cómo usando Gradle podemos dividir el proyecto en varios módulos. No deja de ser un ejemplo pero es bastante completo y está formado por dos aplicaciones web, una librería de componentes y otra librería con el modelo de persistencia, usa Spring, jOOQ, Tapestry, PostgreSQL, Docker, Liquibase, … Cuando una aplicación o proyecto crece en algún momento podemos tener necesidad de partir el monolito[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-15T17:00:00Z</dc:date>
  </entry>
</feed>

