<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-07-17T14:02:12Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-07-17T14:02:12Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Utilizando Spring MVC Bean Validation</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/07/utilizando-spring-mvc-bean-validation" />
    <category term="spring-conceptos" />
    <category term="spring-mvc" />
    <category term="spring-buenas-practicas" />
    <category term="spring" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-07-17T13:43:20Z</updated>
    <published>2015-07-17T13:43:20Z</published>
    <content type="html">&lt;p&gt;Spring MVC Bean Validation es una de las características más utilizadas de Spring MVC y nos permite apoyarnos en  la JSR 303 (Bean Validation ) para validar la información de los objetos que estemos introduciendo con un  formulario. Para ello deberemos incluir en el proyecto de Maven las dependencias de Spring MVC así como las de Hibernate Validator que implementa la especificación JSR 303. 

&lt;dependencies&gt;

&lt;dependency&gt;
 &lt;groupId&gt;org.springframework&lt;/groupId&gt;
 &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
 &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
 &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
 &lt;artifactId&gt;jstl&lt;/artifactId&gt;
 &lt;version&gt;1.2&lt;/version&gt;
 &lt;scope&gt;provided&lt;/scope&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
 &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
 &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
 &lt;version&gt;2.5&lt;/version&gt;
[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/07/utilizando-spring-mvc-bean-validation"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-07-17T13:43:20Z</dc:date>
  </entry>
  <entry>
    <title>Spring MVC @ModelAttribute</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/07/spring-mvc-modelattribute" />
    <category term="spring-conceptos" />
    <category term="spring-mvc" />
    <category term="spring" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-07-09T07:31:10Z</updated>
    <published>2015-07-09T07:31:10Z</published>
    <content type="html">&lt;p&gt;Cada día se usa más Spring MVC  como framework de capa de presentación. Con los años se ha pasado de un modelo MVC con fuerte uso de ficheros XML a un modelo en el que priman las anotaciones. Una de las anotaciones más habituales es Spring MVC @ModelAttribute que nos permite realizar un binding de los datos que tenemos en un formulario de Spring con la capa de backend. @ModelAttribute Supongamos que tenemos un Controller en Spring MVC con dos métodos que mapean URLs (formularioPersona y verPersona) 
package com.arquitecturajava.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;

import com.arquitecturajava.negocio.Persona;

@Controller
public[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/07/spring-mvc-modelattribute"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-07-09T07:31:10Z</dc:date>
  </entry>
  <entry>
    <title>El futuro Java EE 7 vs Spring Framework</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/05/el-futuro-java-ee-7-vs-spring-framework" />
    <category term="spring-conceptos" />
    <category term="ejb" />
    <category term="spring" />
    <category term="jee" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-05-06T08:52:27Z</updated>
    <published>2015-05-06T08:52:27Z</published>
    <content type="html">&lt;p&gt;Java EE 7 vs Spring Framework es una de las comparativas que cada día empezaremos a ver mas. En muchas ocasiones he escuchado que Spring Framework va a morir y que los standards se van a imponer, ya que realizan todas las tareas que realiza Spring Framework. Lo sorprendente es que esto ya lo escuché cuando llego Java EE 5 y cuando llego Java EE 6 y seguimos igual. ¿Porque esto no acaba de pasar?. Standards y Extensibilidad Cuando utilizamos los standards como por ejemplo los Ejb tenemos la ventaja de que nuestro servidor de aplicaciones nos aporta todo lo que necesitamos. Sin embargo no tenemos una gran capacidad para extenderlo y añadir nuevas funcionalidades que consideremos necesarias. El servidor de aplicaciones nos provee de todo para lo bueno y para lo malo.   Spring Framework  y puntos[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/05/el-futuro-java-ee-7-vs-spring-framework"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-05-06T08:52:27Z</dc:date>
  </entry>
  <entry>
    <title>Spring Singleton vs Prototype</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/04/spring-singleton-vs-prototype" />
    <category term="spring-conceptos" />
    <category term="spring" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-04-14T06:14:37Z</updated>
    <published>2015-04-14T06:14:37Z</published>
    <content type="html">&lt;p&gt;Spring Singleton vs Prototype es una de las preguntas clásicas de Spring Framework y a muchas personas les surgen dudas sobre como funciona el scope o ámbito de los beans que generamos. Vamos a intentar aclararlo con un ejemplo sencillo. Supongamos que tenemos la siguiente clase de servicio con su interface. 

package com.arquitecturajava;

public interface ServicioTareas {
 public void lanzar();
}

package com.arquitecturajava;

public class ServicioTareasImpl implements ServicioTareas{

public void lanzar() {

 System.out.println("Tarea1");
 System.out.println("Tarea2");
 System.out.println("Tarea3");

 }

}

 Se trata de una sencilla clase que ejecuta tres tareas. La vamos a dar de alta en el application-context.xml. 

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/04/spring-singleton-vs-prototype"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-04-14T06:14:37Z</dc:date>
  </entry>
  <entry>
    <title>Utilizando Spring Profiles</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2015/02/utilizando-spring-profiles" />
    <category term="spring-buenas-practicas" />
    <category term="spring" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2015-02-20T10:05:43Z</updated>
    <published>2015-02-20T10:05:43Z</published>
    <content type="html">&lt;p&gt;Spring es uno de los frameworks más utilizados ya que permite una gran flexibilidad a la hora de configurarlo. Una de las características menos conocidas del framework es el uso de Profiles. Los Profiles o perfiles permiten configurar grupos de elementos del framework para un “perfil” de ejecución predeterminado. Vamos a verlos a traves de un ejemplo sencillo. Para ello usaremos Maven y las siguientes dependencias: 

&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-core&lt;/artifactId&gt;
&lt;version&gt;3.2.13.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
&lt;version&gt;3.2.13.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
&lt;version&gt;3.2.13.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2015/02/utilizando-spring-profiles"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2015-02-20T10:05:43Z</dc:date>
  </entry>
  <entry>
    <title>Java EE 6 vs Spring Framework 4 (Video)</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2014/10/java-ee-6-vs-spring-framework-4-video" />
    <category term="patrones" />
    <category term="spring" />
    <category term="jee" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2014-10-31T11:14:24Z</updated>
    <published>2014-10-31T11:14:24Z</published>
    <content type="html">&lt;p&gt;Comparativa entre Java EE 6 y Spring Framework 4 .Otros videos relacionados con Java EE 6 vs Spring Framework 4: Spring MVC vs JSF ,POJOS, DTO y VO   La entrada Java EE 6 vs Spring Framework 4 (Video) aparece primero en Arquitectura Java.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2014/10/java-ee-6-vs-spring-framework-4-video"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2014-10-31T11:14:24Z</dc:date>
  </entry>
  <entry>
    <title>Spring @Inject  CDI y standards</title>
    <link rel="alternate" href="http://www.blogstack.info/post/arquitecturajava/2014/09/spring-inject-cdi-y-standards" />
    <category term="anotaciones" />
    <category term="spring" />
    <category term="jee" />
    <category term="standards" />
    <author>
      <name>Cecilio Álvarez Caules</name>
    </author>
    <updated>2014-09-19T13:57:42Z</updated>
    <published>2014-09-19T13:57:42Z</published>
    <content type="html">&lt;p&gt;La competencia entre los standares de Java EE y el framework Spring es cada vez más dura ya que las similitudes entre ambos son muchas. Elegir uno u otro depende de muchas cosas. En estos momentos existen muchos proyectos de Spring y algunos de ellos están valorando pasarse a Java EE en futuras evoluciones. Por ejemplo proyectos con JSF ya que la integración en Java EE es más sencilla al pertenecer al propio estandar. Si nos encontramos en situaciones como estas o similares. Podemos programar la aplicación de Spring para que use anotaciones que están dentro de los standares de de Java EE y nos facilite las migraciones. Spring @Inject Los servicios serán anotados con las siguientes anotaciones  del standard y no con las de Spring: @Named: Identifica una clase para que sea registrada y accesible[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/arquitecturajava/2014/09/spring-inject-cdi-y-standards"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Cecilio Álvarez Caules</dc:creator>
    <dc:date>2014-09-19T13:57:42Z</dc:date>
  </entry>
</feed>

