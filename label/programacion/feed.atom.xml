<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-04-11T23:48:23Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-04-11T23:48:23Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Productividad y errores de compilación con Apache Tapestry</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/productividad-y-errores-de-compilacion-con-apache-tapestry" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="tapestry" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-04-10T18:00:00Z</updated>
    <published>2015-03-27T18:13:12Z</published>
    <content type="html">&lt;p&gt;Hace ya unos años comentaba varios motivos para elegir Apache Tapestry como framework para desarrollar una aplicación o página web. Entre las varias razones comentaba la productividad como característica destacada. Uno de los motivos es esta productividad era por la alta reutilización de código que se puede conseguir al usar los componentes múltiples veces en un mismo proyecto o en diferentes proyectos creando una librería de componentes como comento más detalladamente en el libro PugIn Tapestry. Otra parte de la productividad que comentaba más ligeramente era poder detectar de forma rápida errores de compilación no solo en el código Java a través del IDE sino porque con Tapestry es posible detectar errores de compilación en todas las plantillas tml que generan el html fácil y rápidamente con[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/productividad-y-errores-de-compilacion-con-apache-tapestry"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-27T18:13:12Z</dc:date>
  </entry>
  <entry>
    <title>Guardar contraseñas usando Salted Password Hashing y otras formas correctas</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/04/guardar-contrasenas-usando-salted-password-hashing-y-otras-formas-correctas" />
    <category term="planeta-arch-linux" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="seguridad" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-04-10T16:55:04Z</updated>
    <published>2015-04-10T16:55:04Z</published>
    <content type="html">&lt;p&gt;Para cada servicio deberíamos emplear una contraseña de una longitud de al menos 8 caracteres que incluya letras en minúscula, mayúscula, números y símbolos, una herramienta que podemos utilizar para generar contraseñas más seguras con los criterios que indiquemos es Strong Password Generator. Sin embargo, recordar cada una de estas contraseñas es muy difícil de modo que es habitual que utilicemos la misma contraseña para varios o todos los servicios y no empleando todos los criterios anteriores. Por otro lado, los desarrolladores no deberíamos guardar en la base de datos las contraseñas que nos entregan los usuarios en texto plano, para evitar guardalas en texto plano hace un tiempo se utilizaba únicamente una función de hashing unidireccional como MD5 o SHA, de este modo si la base de datos[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/04/guardar-contrasenas-usando-salted-password-hashing-y-otras-formas-correctas"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-04-10T16:55:04Z</dc:date>
  </entry>
  <entry>
    <title>Evitar iniciar varias veces la máquina virtual Java para procesos cortos</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/04/evitar-iniciar-varias-veces-la-maquina-virtual-java-para-procesos-cortos" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-04-03T20:22:51Z</updated>
    <published>2015-04-03T20:22:51Z</published>
    <content type="html">&lt;p&gt;Si en una aplicación o proyecto tenemos necesidad de ejecutar uno o varios procesos múltiples veces donde únicamente cambian los parámetros, de forma seguida y el tiempo de ejecución de esos procesos es corto probablemente quizá veamos que la mayor parte del tiempo empleado de los procesos sea empleado en iniciar la máquina virtual Java (JVM). Digo quizá porque usando Ubuntu en la nube de Amazon EC2 el tiempo de inicio era de varios segundos, sin embargo, en mi ordenador personal usando Arch Linux y con un disco SSD de Samsung los tiempos que obtengo son de unos pocos milisegundos, quizá la larga lista de dependencias del paquete de Java 7 en Ubuntu (probablemente del paquete openjdk-7-jre) y ocupando considerablemente más megas en disco tenga algo que ver: Por ejemplo, supongamos que tenemos[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/04/evitar-iniciar-varias-veces-la-maquina-virtual-java-para-procesos-cortos"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-04-03T20:22:51Z</dc:date>
  </entry>
  <entry>
    <title>Introducción y ejemplo de API RPC con Apache Thrift</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/introduccion-y-ejemplo-de-api-rpc-con-apache-thrift" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-21T10:30:00Z</updated>
    <published>2015-03-20T16:03:18Z</published>
    <content type="html">&lt;p&gt;Las aplicaciones están pasando de ser elementos aislados, grandes y monolíticos a ser desarrolladas como varios microservicios que colaboran entre si para en conjunto ofrecer la funcionalidad deseada. Aunque los microservicios presentan sus propias problemáticas resuelven algunas que poseen los sistemas monolíticos, entre algunas de sus caracteríticas deseables están: mayor cohesión, menor acoplamiento, menor tamaño, mayor independencia de la tecnología usando la más adecuada en cada situación, más fácilmente reemplazables y despliegues más sencillos. También, la funcionalidad ofrecida por una aplicación puede quererse consumirse desde otra aplicación surgiendo de esta forma una API. Para ofrecer una API de una aplicación que pueda consumirse internamente, desde diferentes dispositivos o por[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/introduccion-y-ejemplo-de-api-rpc-con-apache-thrift"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-20T16:03:18Z</dc:date>
  </entry>
  <entry>
    <title>Aplicación web Java autocontenida con Tomcat Embedded</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-20T17:00:00Z</updated>
    <published>2015-03-14T09:32:20Z</published>
    <content type="html">&lt;p&gt;La tendencia de las aplicaciones es que sean construidas como múltiples servicios pequeños que colaboran entre si en vez de consistir en una aplicación grande desplegada en un servidor de aplicaciones. La aparición de nuevas tecnologías como Docker facilitan la construcción y despliegue de los microservicios. Los microservicios con su máxima de bajo acoplamiento y alta cohesión tratan de incluir todo lo necesario para funcionar evitando las dependencias de cualquier tipo de elemento fuera de su ámbito no incluyendo el uso de otros servicios. Con Docker es posible desplegarlos en cualquier máquina que disponga del servicio, esto evita problemas de configuración al pasar la aplicación de un entorno de desarrollo a uno de producción ya que las características del entorno de desarrollo y el de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/aplicacion-web-java-autocontenida-con-tomcat-embedded"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-14T09:32:20Z</dc:date>
  </entry>
  <entry>
    <title>Datos de sesión externalizados con Spring Session</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/03/datos-de-sesion-externalizados-con-spring-session" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-03-08T02:30:00Z</updated>
    <published>2015-03-07T08:05:06Z</published>
    <content type="html">&lt;p&gt;Por defecto los datos de la sesión de una aplicación web Java se guardan en el servidor de aplicaciones y en memoria, esto produce que al reiniciar el servidor por un despliegue los datos de la sesión se pierdan y provoque en los usuarios alguna molestia como tener que volver a iniciar sesión. En Tomcat existe la posibilidad de que los datos de las sesiones sean persistidas en disco con la opción saveOnRestart del elemento de configuración Manager que evita que los datos de las sesiones se pierdan en los reinicios, al menos para los servicios formados por una única instancia. Para evitar que los usuarios perciban los reinicios o caídas del servidor hay varias soluciones algunas tratando de diferentes formas externalizar las sesiones del servidor de aplicaciones. Con estas soluciones se pueden[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/03/datos-de-sesion-externalizados-con-spring-session"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-03-07T08:05:06Z</dc:date>
  </entry>
  <entry>
    <title>Listener de eventos de Hibernate con servicios de Spring</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/02/listener-de-eventos-de-hibernate-con-servicios-de-spring" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-02-28T09:59:08Z</updated>
    <published>2015-02-28T09:59:08Z</published>
    <content type="html">&lt;p&gt;En el anterior artículo explicaba como crear un listener que reciba eventos de Hibernate pero quizá necesitemos en el listener hacer uso de un servicio de Spring si el proceso de la acción necesita aprovecharse de la funcionalidad proporcionada en los servicios. En este artículo mostraré como crear un listener de Hibernate que use un servicio de Spring, es decir, un listener de Hibernate con la posibilidad de inyectar servicios de Spring. Para hacer la integración de los listeners con Spring debemos sustituir el Interceptor por un servicio que haga lo mismo pero al inicio del contenedor de Spring con la anotación @PostConstruct. Para ello creamos una clase con el siguiente contenido: package es.com.blogspot.elblogdepicodev.plugintapestry.services.hibernate;

import javax.annotation.PostConstruct;

import[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/02/listener-de-eventos-de-hibernate-con-servicios-de-spring"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-02-28T09:59:08Z</dc:date>
  </entry>
</feed>

