<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-11-08T18:02:15Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-11-08T18:02:15Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Java para tareas de scripting</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-08T17:00:00Z</updated>
    <published>2015-11-07T14:00:00Z</published>
    <content type="html">&lt;p&gt;Para programar pequeños scripts normalmente se suele emplear el intérprete de comandos en GNU/Linux bash o si es algo complejo un lenguaje interpretado como Python, Ruby o Groovy. Pero no pienses que Java no puede ser empleado para tareas de scripting, en este artículo muestro que problemas presentan los lenguajes interpretados o dinámicos, que ventajas tiene usar Java y finalmente como usarlo con la misma sencillez que un lenguaje interpretado para el nicho funcional de los scripts. Java puede emplearse para cualquier propósito desde aplicaciones web en la parte servidora, aplicaciones de escritorio como escribí en dos artículos introductorios sobre JavaFX, juegos con alta calidad gráfica incluso para dispositivos de capacidades más reducidas como IoT o embebidos y verdaderamente limitados.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/11/java-para-tareas-de-scripting"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-11-07T14:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Características de los lenguajes de programación</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/caracteristicas-de-los-lenguajes-de-programacion" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="planeta-linux" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-11-03T19:20:00Z</updated>
    <published>2015-10-31T11:00:00Z</published>
    <content type="html">&lt;p&gt;Hay numerosos y diferentes lenguajes de programación pero solo una docena tienen una cuota de uso significativa. Muchos comparten características y algunos lenguajes las van incorporando a medida que se demuestra que sus beneficios son mayores que la complejidad que pueden añadir. Veamos algunas de sus propiedades. Hay cantidad de lenguajes de programación, algunas diferencias entre ellos se encuentran su propósito (general o específico para cierto tipo de tareas), en la sintaxis, el sistema de tipos, por los paradigmas de programación que soporta (POO, imperativo, funcional, …), otras diferencias están en la librerías disponibles, frameworks o comunidad, sin embargo, la mayoría comparten algunas características por las que se pueden catalogar los lenguajes. En este artículo comentaré algunas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/caracteristicas-de-los-lenguajes-de-programacion"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-31T11:00:00Z</dc:date>
  </entry>
  <entry>
    <title>El patrón de diseño Observer y una forma de implementarlo en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-26T21:00:00Z</updated>
    <published>2015-10-24T10:00:00Z</published>
    <content type="html">&lt;p&gt;Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón Observer. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón Observer nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga. En Java este patrón podemos implementarlo usando una clase, la clase Observable, y una interfaz, la interfaz Observer proporcionadas en el propio JDK. La clase que queremos que reciba los eventos deberá implementar la interfaz Observer y el objeto que queremos que produzca los eventos debe extender o contener una propiedad de tipo Observable. La interfaz Observer contiene[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-24T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo del patrón de diseño Observer y una forma de implementarlo en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/ejemplo-del-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-24T21:00:00Z</updated>
    <published>2015-10-24T10:00:00Z</published>
    <content type="html">&lt;p&gt;Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón Observer. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón Observer nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga. En Java este patrón podemos implementarlo usando una clase, la clase Observable, y una interfaz, la interfaz Observer proporcionadas en el propio JDK. La clase que queremos que reciba los eventos deberá implementar la interfaz Observer y el objeto que queremos que produzca los eventos debe extender o contener una propiedad de tipo Observable. La interfaz Observer contiene[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/ejemplo-del-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-24T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Cómo crear clases factoría sin usar if-else</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-19T17:00:00Z</updated>
    <published>2015-10-18T10:00:00Z</published>
    <content type="html">&lt;p&gt;En el artículo cómo crear clases factoría sin usar if-else se comentan varias formas para conseguirlo. Las soluciones que se proponen son usar: Reflection: sin embargo esta solución obliga a que el cliente de la factoría conozca el nombre completo de la clase a crear incluyendo el paquete en el que está y hace que la factoría no abstraiga al cliente de conocerlo que puede ser uno de sus objetivos. Además el parámetro es un String con lo que en los refactors el compilador no nos ayudará, el compilador es una de mis 10 razones para seguir usando Java. Map: en esta solución se asocia una clave (en String) con la clase que devuelve la factoría. Igualmente usar un String como clave es algo a evitar ya que es propenso a errores al no tener ayuda del compilador en los valores de los Strings si estas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-18T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Aplicación Java autocontenida con Spring Boot</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/aplicacion-java-autocontenida-con-spring-boot" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-12T22:00:00Z</updated>
    <published>2015-10-12T22:00:00Z</published>
    <content type="html">&lt;p&gt;Si queremos una aplicación Java autocontenida ya sea una aplicación de linea de comandos, de escritorio o aplicación web que use el contenedor de dependencias de Spring podemos usar Spring Boot. Además de inicializar el contenedor IoC de Spring, Spring Boot proporciona en una aplicación web elegir el servidor de aplicaciones de entre el por defecto Tomcat y los seleccionables Jetty y Undertow junto con algunas funcionalidades más. Tradicionalmente las aplicaciones Java web han sido instaladas en un contenedor de servlets como Tomcat o Jetty y Wildfly, JBoss o Weblogic si necesita más servicios que son ofrecidos por la plataforma JEE completa como JMS, JPA, JTA o EJB. Aunque las aplicaciones se ejecutan independientemente unas de otras comparten el entorno de ejecución del servidor de aplicaciones,[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/aplicacion-java-autocontenida-con-spring-boot"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-12T22:00:00Z</dc:date>
  </entry>
  <entry>
    <title>JavaFX Scene Builder, editor para crear archivos FXML</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-11T18:00:00Z</updated>
    <published>2015-10-08T22:00:00Z</published>
    <content type="html">&lt;p&gt;Con la aplicación JavaFX Scene Builder podemos construir la interfaz gráfica de una aplicación de escritorio Java de forma más sencilla. JavaFX Scene Builder genera archivos descriptores FXML que podemos cargar en la aplicación evitando la tediosa y no sencilla tarea de construir la interfaz gráfica mediante código. En el artículo comento la aplicación JavaFX Scene Builder, como usar los archivos FXML en una aplicación de escritorio, como asociar manejadores de eventos y como cambiar las propiedades de los controles. Por lo poco que he visto JavaFX es una gran evolución sobre AWT y Swing para desarrollar aplicaciones de escritorio en Java aportando varias mejoras. En el artículo Introducción a JavaFX comentaba que una de las cosas que me parecía más complicada usando tanto AWT y más tarde usando[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-08T22:00:00Z</dc:date>
  </entry>
</feed>

