<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-10-18T14:02:46Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-10-18T14:02:46Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Cómo crear clases factoría sin usar if-else</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-18T14:00:00Z</updated>
    <published>2015-10-18T10:00:00Z</published>
    <content type="html">&lt;p&gt;En el artículo cómo crear clases factoría sin usar if-else se comentan varias formas para conseguirlo. Las soluciones que se proponen son usar: Reflection: sin embargo esta solución obliga a que el cliente de la factoría conozca el nombre completo de la clase a crear incluyendo el paquete en el que está y hace que la factoría no abstraiga al cliente de conocerlo que puede ser uno de sus objetivos. Además el parámetro es un String con lo que en los refactors el compilador no nos ayudará, el compilador es una de mis 10 razones para seguir usando Java. Map: en esta solución se asocia una clave (en String) con la clase que devuelve la factoría. Igualmente usar un String como clave es algo a evitar ya que es propenso a errores al no tener ayuda del compilador en los valores de los Strings si estas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/como-crear-clases-factoria-sin-usar-if-else"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-18T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Aplicación Java autocontenida con Spring Boot</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/aplicacion-java-autocontenida-con-spring-boot" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-12T22:00:00Z</updated>
    <published>2015-10-12T22:00:00Z</published>
    <content type="html">&lt;p&gt;Si queremos una aplicación Java autocontenida ya sea una aplicación de linea de comandos, de escritorio o aplicación web que use el contenedor de dependencias de Spring podemos usar Spring Boot. Además de inicializar el contenedor IoC de Spring, Spring Boot proporciona en una aplicación web elegir el servidor de aplicaciones de entre el por defecto Tomcat y los seleccionables Jetty y Undertow junto con algunas funcionalidades más. Tradicionalmente las aplicaciones Java web han sido instaladas en un contenedor de servlets como Tomcat o Jetty y Wildfly, JBoss o Weblogic si necesita más servicios que son ofrecidos por la plataforma JEE completa como JMS, JPA, JTA o EJB. Aunque las aplicaciones se ejecutan independientemente unas de otras comparten el entorno de ejecución del servidor de aplicaciones,[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/aplicacion-java-autocontenida-con-spring-boot"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-12T22:00:00Z</dc:date>
  </entry>
  <entry>
    <title>JavaFX Scene Builder, editor para crear archivos FXML</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-11T18:00:00Z</updated>
    <published>2015-10-08T22:00:00Z</published>
    <content type="html">&lt;p&gt;Con la aplicación JavaFX Scene Builder podemos construir la interfaz gráfica de una aplicación de escritorio Java de forma más sencilla. JavaFX Scene Builder genera archivos descriptores FXML que podemos cargar en la aplicación evitando la tediosa y no sencilla tarea de construir la interfaz gráfica mediante código. En el artículo comento la aplicación JavaFX Scene Builder, como usar los archivos FXML en una aplicación de escritorio, como asociar manejadores de eventos y como cambiar las propiedades de los controles. Por lo poco que he visto JavaFX es una gran evolución sobre AWT y Swing para desarrollar aplicaciones de escritorio en Java aportando varias mejoras. En el artículo Introducción a JavaFX comentaba que una de las cosas que me parecía más complicada usando tanto AWT y más tarde usando[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-08T22:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Introducción a JavaFX, aplicaciones de escritorio en Java</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-11T10:00:00Z</updated>
    <published>2015-10-02T17:00:00Z</published>
    <content type="html">&lt;p&gt;Java tiene una fuerte presencia en el ámbito de desarrollo para aplicaciones web, más recientemente ha sido empleado por la plataforma Android. En la misma medida que han crecido las aplicaciones web y móviles nativas las aplicaciones de escritorio han perdido presencia, sin embargo, para ciertos casos son la opción adecuada. Con la aparición de JavaFX aportando varias mejoras sobre Swing o AWT en la plataforma Java se pueden desarrollar aplicaciones de escritorio multiplataforma «ricas». Podemos empezar por el ejemplo Hola Mundo de JavaFX de este artículo. El lenguaje de programación Java es ampliamente usado en el ámbito empresarial destacando la programación de aplicaciones web. Las aplicaciones web se han extendido tanto por su fácil despliegue a los clientes (un navegador basta), un desarrollo[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-10-02T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo de multiproyecto con Gradle</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="tapestry" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-10-04T17:30:00Z</updated>
    <published>2015-09-15T17:00:00Z</published>
    <content type="html">&lt;p&gt;En un proyecto grande podemos tener necesidad de dividir el monolito al menos en varios módulos y yendo un paso más lejos en microservicios. La herramienta de construcción que usemos deberá de facilitarnos automatizar la tarea de construcción del código fuente de cada módulo individual, de todos a la vez o de los microservicios si tienen alguna dependencia compartida. En el artículo y ejemplo explicaré cómo usando Gradle podemos dividir el proyecto en varios módulos. No deja de ser un ejemplo pero es bastante completo y está formado por dos aplicaciones web, una librería de componentes y otra librería con el modelo de persistencia, usa Spring, jOOQ, Tapestry, PostgreSQL, Docker, Liquibase, … Cuando una aplicación o proyecto crece en algún momento podemos tener necesidad de partir el monolito[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-de-multiproyecto-con-gradle"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-15T17:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Ejemplo del patrón de diseño Builder</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-del-patron-de-diseno-builder" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-09-27T14:00:00Z</updated>
    <published>2015-09-27T10:00:00Z</published>
    <content type="html">&lt;p&gt;Construir objetos es una tarea básica en los lenguajes orientados a objetos. En Java, las instancias de una clase se crean con la palabra clave reservada new y un método especial llamado constructor. Al diseñar una clase debemos tener algunas cuestiones para evitar varios constructores telescópicos, evitar constructores que son combinación de varios argumentos opcionales y permitir obtener instancias de objetos con estado válido. Si se nos presentan estas situaciones podemos usar el patrón de diseño Builder que consiste en básicamente en una clase especializada en construir instancias de otra clase que podemos hacer usable con una API fluida y alguna cosa más deseable que explico en el artículo. Al escribir los métodos constructores de instancias de una clase puede ocurrirnos que algunos de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/ejemplo-del-patron-de-diseno-builder"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-27T10:00:00Z</dc:date>
  </entry>
  <entry>
    <title>Generar recursos estáticos con wro4j</title>
    <link rel="alternate" href="http://www.blogstack.info/post/blogbitix/2015/09/generar-recursos-estaticos-con-wro4j" />
    <category term="programacion" />
    <category term="blog-stack" />
    <category term="java" />
    <category term="planeta-codigo" />
    <author>
      <name>pico.dev</name>
    </author>
    <updated>2015-09-25T15:00:00Z</updated>
    <published>2015-09-25T15:00:00Z</published>
    <content type="html">&lt;p&gt;Con nuevas tecnologías como less, Sass o CoffeeScript el desarrollo y mantenimiento de una página web medianamente compleja mejora notablemente. Con la librería wro4j en una aplicación Java podemos procesar este tipo de recursos y convertirlos a los equivalentes que saben interpretar los navegadores de forma nativa CSS y JavaScript además de optimizar su tamaño u ofuscarlos. El desarrollo y las tecnologías de las páginas web sigue evolucionando, HTML 5, JavaScript, CSS 3, diseño adaptable (responsive), … Y también surgen nuevas herramientas que hacen el desarrollo más simple o hace que las aplicaciones sean más eficientes. Algunas de estas nuevas tecnologías son less o Sass que permiten producir hojas de estilo CSS utilizando una mejor notación, si la hoja de estilos es grande usar una tecnología[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/blogbitix/2015/09/generar-recursos-estaticos-con-wro4j"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>pico.dev</dc:creator>
    <dc:date>2015-09-25T15:00:00Z</dc:date>
  </entry>
</feed>

