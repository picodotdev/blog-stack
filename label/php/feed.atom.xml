<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2015-03-09T10:03:15Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2015-03-09T10:03:15Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Magento: insertar bloques CMS dentro de nuestras plantillas</title>
    <link rel="alternate" href="http://www.blogstack.info/post/poesiabinaria/2015/03/magento-insertar-bloques-cms-dentro-de-nuestras-plantillas" />
    <category term="usuarios" />
    <category term="flexibilidad" />
    <category term="php" />
    <category term="cms" />
    <category term="plantilla" />
    <category term="magento" />
    <category term="bloque" />
    <category term="empotrar" />
    <author>
      <name>Gaspar Fernández</name>
    </author>
    <updated>2015-03-09T09:28:36Z</updated>
    <published>2015-03-09T09:28:36Z</published>
    <content type="html">&lt;p&gt;Para dar flexibilidad a nuestros desarrollos con Magento y con el fin de permitir a los usuarios administradores cambiar fácilmente el contenido de su tienda hecha con Magento. Una buena opción es facilitar bloques estáticos de CMS dentro de nuestras plantillas. Por ejemplo, podemos empotrar un texto dedicado a la manipulación y al envío dentro de cada producto; o, es más, podemos tener varios modelos de bloques de manipulación y envío y que sea un atributo del artículo el que decida qué bloque mostrar. Para introducir un bloque MS dentro de nuestra plantilla tendremos que hacer: 1 echo $this-&gt;getLayout()-&gt;createBlock('cms/block')-&gt;setBlockId('identificador-de-bloque')-&gt;toHtml() La entrada Magento: insertar bloques CMS dentro de nuestras plantillas aparece primero en Poesía Binaria.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/poesiabinaria/2015/03/magento-insertar-bloques-cms-dentro-de-nuestras-plantillas"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Gaspar Fernández</dc:creator>
    <dc:date>2015-03-09T09:28:36Z</dc:date>
  </entry>
  <entry>
    <title>Magento: Conocer qué página de CMS se está visualizando ahora mismo</title>
    <link rel="alternate" href="http://www.blogstack.info/post/poesiabinaria/2015/03/magento-conocer-que-pagina-de-cms-se-esta-visualizando-ahora-mismo" />
    <category term="controlador" />
    <category term="principal" />
    <category term="identificador" />
    <category term="php" />
    <category term="pagina" />
    <category term="cms" />
    <category term="plantilla" />
    <category term="magento" />
    <category term="template" />
    <category term="home" />
    <author>
      <name>Gaspar Fernández</name>
    </author>
    <updated>2015-03-02T10:14:42Z</updated>
    <published>2015-03-02T10:14:42Z</published>
    <content type="html">&lt;p&gt;Puede ser muy útil, sobre todo cuando estamos creando o modificando las plantillas principales de nuestro tema en Magento saber si la página actual se trata de una página de CMS. Esto lo podemos saber muy fácilmente con: 1 $route = Mage:app()-&gt;getRequest()-&gt;getRouteName(); La variable route tendrá el valor “cms” si se trata de una página CMS, o podrá obtener el valor de la ruta del controlador actual (dependiendo de si estamos en el carrito, página de categoría, producto, dentro de un plugin, etc). En el caso que sea una página CMS podremos preguntar también el identificador que se está visualizando con: 1 $ident = Mage::getSingleton('cms/page')-&gt;getIdentifier(); Dependiendo de la ruta donde estemos, podremos llamar a un método o a otro. Ahora, juntándolo todo: 1 2 if (Mage:app()-&gt;getRequest()-&gt;getRouteName()[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/poesiabinaria/2015/03/magento-conocer-que-pagina-de-cms-se-esta-visualizando-ahora-mismo"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Gaspar Fernández</dc:creator>
    <dc:date>2015-03-02T10:14:42Z</dc:date>
  </entry>
  <entry>
    <title>Magento: Saber si estamos en la página principal (home page)</title>
    <link rel="alternate" href="http://www.blogstack.info/post/poesiabinaria/2015/02/magento-saber-si-estamos-en-la-pagina-principal-home-page" />
    <category term="html" />
    <category term="conocer" />
    <category term="principal" />
    <category term="php" />
    <category term="pagina" />
    <category term="getishomepage" />
    <category term="plantilla" />
    <category term="inicio" />
    <category term="magento" />
    <category term="bloque" />
    <category term="home" />
    <author>
      <name>Gaspar Fernández</name>
    </author>
    <updated>2015-02-23T09:57:34Z</updated>
    <published>2015-02-23T09:57:34Z</published>
    <content type="html">&lt;p&gt;Cuando estamos trabajando con Magento, en ocasiones necesitamos conocer si actualmente nos encontramos en la home de nuestro sitio o en cualquier otra página. Normalmente, la home, tendrá un diseño diferente y por eso debemos diferenciarla de las demás. Para ello, desde Magento 1.5+ tenemos una función que nos puede ayudar mucho en esta misión. Si nos encontramos en el header.phtml podemos comprobarlo llamando a: GeSHi Error: GeSHi could not find the language cc (using path /home/gaspy/www/totaki.com/www/poesiabinaria/wp-content/plugins/codecolorer/lib/geshi/) (code 2) Pero si nos encontramos en cualquier otra plantilla, tenemos que llamar a esa misma función que se encuentra en el header, para ello obtenemos el singleton del header y se lo preguntamos: GeSHi Error: GeSHi could not find the[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/poesiabinaria/2015/02/magento-saber-si-estamos-en-la-pagina-principal-home-page"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Gaspar Fernández</dc:creator>
    <dc:date>2015-02-23T09:57:34Z</dc:date>
  </entry>
  <entry>
    <title>Limitar el acceso a phpmyadmin</title>
    <link rel="alternate" href="http://www.blogstack.info/post/ochobitshacenunbyte/2015/02/limitar-el-acceso-a-phpmyadmin" />
    <category term="blog-stack" />
    <category term="programas" />
    <category term="web" />
    <category term="phpmyadmin" />
    <category term="php" />
    <category term="apache2" />
    <author>
      <name>davidochobits</name>
    </author>
    <updated>2015-02-17T12:49:30Z</updated>
    <published>2015-02-17T12:49:30Z</published>
    <content type="html">&lt;p&gt;No es ninguna novedad ni sorprenderá a nadie que hable de phpmyadmin, una herramienta escrita en php, que nos ayudará a gestionar las bases de datos de nuestro servidor. Lo que muchas veces podemos obviar es que si un delincuente informático, mal llamados hackers, accediese a dicho panel, le facilitaríamos el camino, cosa que debemos evitar. Hoy veremos cómo limitar el acceso a phpmyadmin Realmente en un par de pasos lo tendremos resuelto. Debemos de modificar un par de archivos para que sólo se puede acceder a dicho panel desde unas IP específicas. Primero de todo crearemos un archivo .htaccess donde indicaremos las IP admitidias y denegaremos todo el resto. El archivo lo debemos de crear en la carpeta /usr/share/phpmyadmin 1
 cd /usr/share/phpmyadmin/ 1
 nano .htaccess Y añadimos las reglas[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/ochobitshacenunbyte/2015/02/limitar-el-acceso-a-phpmyadmin"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>davidochobits</dc:creator>
    <dc:date>2015-02-17T12:49:30Z</dc:date>
  </entry>
  <entry>
    <title>Añadir jerarquía a nuestras colecciones de datos en PHP. Creando árboles en PHP</title>
    <link rel="alternate" href="http://www.blogstack.info/post/poesiabinaria/2015/02/anadir-jerarquia-a-nuestras-colecciones-de-datos-en-php-creando-arboles-en-php" />
    <category term="fotos" />
    <category term="peticiones" />
    <category term="elementos" />
    <category term="jerarquia" />
    <category term="complejidad" />
    <category term="rendimiento" />
    <category term="php" />
    <category term="arboles" />
    <category term="datos" />
    <category term="base" />
    <category term="coleccion" />
    <category term="buildtree" />
    <category term="general" />
    <category term="categorias" />
    <author>
      <name>Gaspar Fernández</name>
    </author>
    <updated>2015-02-05T16:10:42Z</updated>
    <published>2015-02-05T16:10:42Z</published>
    <content type="html">&lt;p&gt;Es una práctica muy común categorizar nuestros. Hacer que existan categorías/sub-categorías/sub-sub-categorías sin límite al igual que directorios o carpetas hay en nuestro ordenador necesitamos tener todo clasificado. Es decir, queremos introducir jerarquía en nuestros datos, hacer que unos campos dependan de otros. Pero cuando guardamos la información en base de datos, normalmente se guardarán en una tabla con dos dimensiones, por lo que perdemos esa sensación de que hay unos datos dentro de otros. Lo normal en estos casos, es que en cada fila de nuestra tabla haya un campo extra que apunta al identificador de la entrada que establecemos como padre. Por ejemplo, si intentamos introducir categorías de pintura, tendremos por ejemplo: Género pictórico Histórica Prehistoria Edad antigua Edad[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/poesiabinaria/2015/02/anadir-jerarquia-a-nuestras-colecciones-de-datos-en-php-creando-arboles-en-php"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>Gaspar Fernández</dc:creator>
    <dc:date>2015-02-05T16:10:42Z</dc:date>
  </entry>
  <entry>
    <title>Instalar LEMP (Nginx, MariaDB  y PHP) en Debian 7</title>
    <link rel="alternate" href="http://www.blogstack.info/post/ochobitshacenunbyte/2014/11/instalar-lemp-nginx-mariadb-y-php-en-debian-7" />
    <category term="lemp" />
    <category term="mysql" />
    <category term="blog-stack" />
    <category term="nginx" />
    <category term="sistemas-operativos" />
    <category term="mariadb" />
    <category term="web" />
    <category term="php" />
    <category term="debian" />
    <author>
      <name>davidochobits</name>
    </author>
    <updated>2014-11-23T16:42:44Z</updated>
    <published>2014-11-14T12:21:00Z</published>
    <content type="html">&lt;p&gt;LEMP es una combinación de un sistema operativo Linux con servicios enfocados a la web (Nginx,MariaDB y PHP). A diferencia de LAMP, utilizaremos Nginx cómo servidor web en vez de Apache. Nginx, es un servidor web ligero y de alto rendemiento, también se puede utilizar cómo proxy para protocolos de correo electrónico. Es software libre, utiliza la licencia BSD, y multiplataforma, ya que es compatible con GNU/Linux, BSD y devirados, Solaris, MAC OS X y Windows)   Instalación de LEMP en Debian 7 Wheezy Para la instalación cómo sistema operativo usaremos GNU/Linux Debian 7. Nginx ya viene en los repositorios main, así que instalarlo es muy fácil: 1
 apt-get -y update &amp;&amp; apt-get -y install nginx A diferencia de Apache, no arranca automaticamente una vez instalado, por lo tanto lo iniciamos: 1
 service[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/ochobitshacenunbyte/2014/11/instalar-lemp-nginx-mariadb-y-php-en-debian-7"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>davidochobits</dc:creator>
    <dc:date>2014-11-14T12:21:00Z</dc:date>
  </entry>
  <entry>
    <title>GLPI, Mucho más que un gestor de parque informático</title>
    <link rel="alternate" href="http://www.blogstack.info/post/ochobitshacenunbyte/2014/10/glpi-mucho-mas-que-un-gestor-de-parque-informatico" />
    <category term="blog-stack" />
    <category term="programas" />
    <category term="glpi" />
    <category term="php" />
    <category term="comunidad-open-source" />
    <category term="linux" />
    <category term="debian" />
    <category term="apache2" />
    <author>
      <name>ochobitshacenunbyte</name>
    </author>
    <updated>2014-10-15T09:23:09Z</updated>
    <published>2014-10-06T15:32:59Z</published>
    <content type="html">&lt;p&gt;GLPI es un acrónimo del fránces que significa “Gestionnaire libre de parc informatique”, es decir, Gestión Libre del Parque Informático. Está escrito PHP y liberado usando la licencia de software libre GNU GPL v2. Se trata un magnífico software que nos permitirá controlar el hardware de nuestra compañía de manera fácil, y no sólo eso, incluso podremos crear un potente sistema te ticketing con nuestro usuarios, con seguimiento de incidencias. Cómo características principales nos encontramos con: Inventario de computadoras, periféricos, impresoras y resto de componentes informáticos habituales. Gestión de incidencias con creación de tickets y seguimiento de éstos últimos. Control financiero. Gestión de la documentación de los equipos. F.A.Q. Soporte hasta 45 idiomas Cuenta con gran cantidad de[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/ochobitshacenunbyte/2014/10/glpi-mucho-mas-que-un-gestor-de-parque-informatico"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>ochobitshacenunbyte</dc:creator>
    <dc:date>2014-10-06T15:32:59Z</dc:date>
  </entry>
</feed>

