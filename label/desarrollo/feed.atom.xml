<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2016-01-24T14:02:51Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2016-01-24T14:02:51Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Gestionar errores 404 (y otros) en ASP.NET Core y MVC</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/12/gestionar-errores-4-4-y-otros-en-asp-net-core-y-mvc" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:27:55Z</updated>
    <published>2015-12-01T08:15:00Z</published>
    <content type="html">&lt;p&gt;Pues no parecía que esto de la gestión de errores fuera a dar para tanto, pero este es ya el tercer post dedicado a este tema, que por otro lado debemos controlar totalmente cuando comencemos a crear aplicaciones reales con ASP.NET Core y MVC. Hasta ahora hemos visto cómo gestionar las excepciones producidas desde nuestras aplicaciones utilizando el middleware ExceptionHandlerMiddleware, y cómo obtener información sobre dichas excepciones desde su código manejador. Esto nos permitía un buen grado de control sobre los errores HTTP 500, pero el amigo Juan, muy atento a lo que íbamos viendo, preguntaba: "Siguiendo con la captura de excepciones, esta vez en mvc6 como se podría capturar los códigos de estado como por ejemplo 404" Obviamente el resto de errores HTTP entre el 400 (errores en cliente)[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/12/gestionar-errores-4-4-y-otros-en-asp-net-core-y-mvc"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-12-01T08:15:00Z</dc:date>
  </entry>
  <entry>
    <title>Custom middlewares en ASP.NET Core</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/12/custom-middlewares-en-asp-net-core" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:22:12Z</updated>
    <published>2015-12-15T08:05:00Z</published>
    <content type="html">&lt;p&gt;El concepto de proceso de peticiones basado en el pipeline no es algo nuevo, pero ciertamente es en ASP.NET Core donde se hace más explícito y visible a los desarrolladores. Y aunque anteriormente también hemos trabajado con middlewares (en ASP.NET 4.x los módulos y handlers podían ejercer funciones similares, y más recientemente, en OWIN ya existía el mismo concepto), es ahora cuando debemos conocerlos bien si queremos llegar a comprender y dominar la nueva plataforma ASP.NET Core. Este este post vamos a profundizar un poco en el proceso de peticiones en ASP.NET Core, y veremos lo sencillo que resulta crear middlewares personalizados que participen en dicho proceso. Cómo se procesa una petición en ASP.NET CoreCuando una petición llega a una aplicación ASP.NET Core, es procesada por los middlewares[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/12/custom-middlewares-en-asp-net-core"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-12-15T08:05:00Z</dc:date>
  </entry>
  <entry>
    <title>Eliminar el encabezado "X-Powered-By" en ASP.NET Core</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2016/01/eliminar-el-encabezado-x-powered-by-en-asp-net-core" />
    <category term="desarrollo" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:15:05Z</updated>
    <published>2016-01-19T07:52:00Z</published>
    <content type="html">&lt;p&gt;Hace poco veíamos cómo crear un middleware capaz de realizar transformaciones simples en los encabezados de respuesta de nuestras aplicaciones ASP.NET Core. Nuestro componente, al que habíamos llamado HeaderTransformMiddleware, podíamos añadirlo al pipeline indicándole qué encabezados queríamos modificar y con qué valores (o nulo, si lo que queríamos era eliminar el encabezado). Por ejemplo, con el siguiente código añadíamos el encabezado "X-Author" y suprimíamos "Server": var transforms = new Dictionary&lt;string, string&gt;() {     ["X-Author"] = "José M. Aguilar",     ["Server"] = null }; app.UseHeaderTransform(transforms); Tras añadirlo al pipeline, la ejecución de una petición a una aplicación podríamos tener el siguiente resultado en los encabezados: HTTP/1.1 200 OK Content-Type: text/html;[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2016/01/eliminar-el-encabezado-x-powered-by-en-asp-net-core"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2016-01-19T07:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Inyección de dependencias en ASP.NET 5 (actualizado)</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/10/inyeccion-de-dependencias-en-asp-net-5-actualizado" />
    <category term="desarrollo" />
    <category term="aspnet5" />
    <category term="aspnetmvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-11-23T08:02:03Z</updated>
    <published>2015-10-06T06:50:00Z</published>
    <content type="html">&lt;p&gt;Hace bastantes meses, allá por febrero, publiqué el post “ Inyección de dependencias en ASP.NET 5”, donde describía el sistema integrado de inyección de dependencias que se estaba construyendo en ASP.NET 5. Sin embargo, las cosas han cambiado un poco desde entonces, por lo que he pensado que sería buena idea reeditar el artículo y actualizarlo al momento actual, con la beta 8 de ASP.NET 5 a punto de publicarse. &lt;disclaimer&gt;Aunque el producto está cada vez más estable y completo, aún podrían cambiar cosas antes de la versión definitiva, incluso antes de tener la release candidate en la calle.&lt;/disclaimer&gt; Si no sabes aún lo que es inyección de dependencias, el resto del post te sonará a arameo antiguo. Quizás podrías echar previamente un vistazo a este otro, Desacoplando controladores ASP.NET[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/10/inyeccion-de-dependencias-en-asp-net-5-actualizado"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-10-06T06:50:00Z</dc:date>
  </entry>
  <entry>
    <title>El archivo _ViewImports en MVC 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/09/el-archivo-viewimports-en-mvc-6" />
    <category term="desarrollo" />
    <category term="novedades" />
    <category term="aspnet5" />
    <category term="aspnetmvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-09-25T19:00:25Z</updated>
    <published>2015-09-22T07:10:00Z</published>
    <content type="html">&lt;p&gt;Desde la llegada de Razor, hace ya bastante tiempo, usamos en MVC el archivo _ViewStart.cshtml de las carpetas de vistas de nuestra aplicación para introducir código de inicialización de éstas. Era un buen lugar para establecer propiedades como el Layout de forma genérica, sin tener que hacerlo en cada una de las vistas que se encontraran por debajo en el árbol de directorios en el que se definía. En MVC 6 se le ha unido un compañero llamado _ViewImports.cshtml, cuya finalidad y funcionamiento es parecido al tradicional ViewStart, porque se procesa antes de ejecutar una vista e igualmente afecta a todas las vistas que se encuentren por debajo de este archivo en el árbol de directorios, aunque aporta algunas diferencias bastante interesantes. Comentamos a continuación los aspectos más destacables.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/09/el-archivo-viewimports-en-mvc-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-09-22T07:10:00Z</dc:date>
  </entry>
  <entry>
    <title>La carpeta wwwroot en ASPNET 5</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/09/la-carpeta-wwwroot-en-aspnet-5" />
    <category term="desarrollo" />
    <category term="aspnet5" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-09-15T07:15:00Z</updated>
    <published>2015-09-15T07:15:00Z</published>
    <content type="html">&lt;p&gt;Seguimos hablando de ASP.NET 5 y los cambios que traerá para los desarrolladores que ya llevamos tiempo utilizando ASP.NET y MVC, porque esta nueva versión viene cargada de cambios y algunos son realmente rompedores. Hoy nos centraremos en un cambio simple, pero bastante importante, que afecta a la estructura de nuestros proyectos: el raíz del sitio web. Desde siempre el directorio raíz de un proyecto ASP.NET, ya fuera Web Forms, MVC, Web API o cualquier otro, coincidía con la raíz del sitio web en el servidor, es decir, en nuestros equipos se mezclaban los archivos propios del desarrollo con los contenidos estáticos que se subían posteriormente a los entornos de prueba o producción. Esto creaba un poco de lío a la hora de publicar los proyectos, porque era fácil que nos dejáramos algo por[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/09/la-carpeta-wwwroot-en-aspnet-5"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-09-15T07:15:00Z</dc:date>
  </entry>
  <entry>
    <title>Código específico para distintos entornos (development, release…) en MVC 6/ASPNET 5</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/07/codigo-especifico-para-distintos-entornos-development-release-en-mvc-6-aspnet-5" />
    <category term="desarrollo" />
    <category term="aspnet5" />
    <category term="aspnetmvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-07-21T11:01:44Z</updated>
    <published>2015-07-21T07:00:00Z</published>
    <content type="html">&lt;p&gt;En versiones anteriores de ASP.NET, podíamos utilizar la expresión HttpContext.Current.IsDebuggingEnabled para determinar si una aplicación web está ejecutándose en modo depuración o no, lo cual podía ser útil a la hora de introducir porciones de código específicas para cada caso. El valor de esa propiedad estaba directamente relacionado con el de la propiedad debug del tag &lt;compilation&gt; presente en el archivo de configuración web.config. Como sabemos, en ASP.NET 5 esto no sería posible por tres motivos: Primero, por la archiconocida desaparición del web.config. Segundo, porque al eliminar la dependencia con System.Web, ya no existen ni HttpContext.Current ni la propia clase estática HttpContext. Y tercero, porque no existe un modo “debug” como tal, sino distintos entornos de ejecución (development,[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/07/codigo-especifico-para-distintos-entornos-development-release-en-mvc-6-aspnet-5"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-07-21T07:00:00Z</dc:date>
  </entry>
</feed>

