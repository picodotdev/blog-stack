<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <title>Blog Stack</title>
  <link rel="alternate" href="http://www.blogstack.info" />
  <subtitle>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</subtitle>
  <updated>2016-04-03T13:02:44Z</updated>
  <dc:creator>Blog Stack</dc:creator>
  <dc:date>2016-04-03T13:02:44Z</dc:date>
  <dc:language>es</dc:language>
  <entry>
    <title>Archivos estáticos en aplicaciones ASP.NET Core (I)</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2016/03/archivos-estaticos-en-aplicaciones-asp-net-core-i" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <category term="aspnetcore" />
    <category term="static-files" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-04-03T12:14:40Z</updated>
    <published>2016-03-29T07:10:00Z</published>
    <content type="html">&lt;p&gt;Una de las principales características del nuevo ASP.NET Core es su diseño modular. El framework no es ahora un mastodonte monolítico sino un gran conjunto de pequeños componentes que incluiremos en nuestras aplicaciones exclusivamente cuando sea necesario. Esto, que a priori se muestra como una ventaja en términos de rendimiento y flexibilidad de nuestros sistemas, presenta también algunos pequeños inconvenientes que debemos tener en cuenta a la hora de desarrollar aplicaciones. Por ejemplo, en versiones anterior de ASP.NET no teníamos que preocuparnos demasiado de la gestión de los archivos estáticos (JS, CSS, HTML, fuentes...) porque teníamos por abajo a IIS que se encargaba de procesar las peticiones a este tipo de recursos. Ahora, tras la llegada de ASP.NET Core, las aplicaciones que utilicen[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2016/03/archivos-estaticos-en-aplicaciones-asp-net-core-i"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2016-03-29T07:10:00Z</dc:date>
  </entry>
  <entry>
    <title>Convenciones personalizadas en ASP.NET Core MVC</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2016/03/convenciones-personalizadas-en-asp-net-core-mvc" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-03-01T08:15:15Z</updated>
    <published>2016-03-01T08:15:00Z</published>
    <content type="html">&lt;p&gt;ASP.NET Core MVC introduce algunas características interesantes que no existían ni tenían un equivalente directo en ASP.NET MVC 5 y anteriores, y entre ellas hay una que me ha llamado mucho la atención y que vamos a comentar en este post: las convenciones personalizadas. Seguro recordaréis que tradicionalmente tanto MVC como Web API han sido frameworks muy guiados por convenciones, es decir, venían de serie diseñados con un conjunto de pautas o normas a las que debíamos ceñirnos si queríamos aprovechar todo su potencial. Teníamos convenciones para las rutas, de ubicación de vistas, para nombrar los controladores, nombrado de acciones según el verbo HTTP mediante el cual se pretendía acceder a una función del API, y algunas más. Algunas de estas convenciones se podían cambiar fácilmente usando[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2016/03/convenciones-personalizadas-en-asp-net-core-mvc"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2016-03-01T08:15:00Z</dc:date>
  </entry>
  <entry>
    <title>Gestionar errores 404 (y otros) en ASP.NET Core y MVC</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/12/gestionar-errores-4-4-y-otros-en-asp-net-core-y-mvc" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:27:55Z</updated>
    <published>2015-12-01T08:15:00Z</published>
    <content type="html">&lt;p&gt;Pues no parecía que esto de la gestión de errores fuera a dar para tanto, pero este es ya el tercer post dedicado a este tema, que por otro lado debemos controlar totalmente cuando comencemos a crear aplicaciones reales con ASP.NET Core y MVC. Hasta ahora hemos visto cómo gestionar las excepciones producidas desde nuestras aplicaciones utilizando el middleware ExceptionHandlerMiddleware, y cómo obtener información sobre dichas excepciones desde su código manejador. Esto nos permitía un buen grado de control sobre los errores HTTP 500, pero el amigo Juan, muy atento a lo que íbamos viendo, preguntaba: "Siguiendo con la captura de excepciones, esta vez en mvc6 como se podría capturar los códigos de estado como por ejemplo 404" Obviamente el resto de errores HTTP entre el 400 (errores en cliente)[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/12/gestionar-errores-4-4-y-otros-en-asp-net-core-y-mvc"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-12-01T08:15:00Z</dc:date>
  </entry>
  <entry>
    <title>Custom middlewares en ASP.NET Core</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/12/custom-middlewares-en-asp-net-core" />
    <category term="desarrollo" />
    <category term="aspnetcoremvc" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:22:12Z</updated>
    <published>2015-12-15T08:05:00Z</published>
    <content type="html">&lt;p&gt;El concepto de proceso de peticiones basado en el pipeline no es algo nuevo, pero ciertamente es en ASP.NET Core donde se hace más explícito y visible a los desarrolladores. Y aunque anteriormente también hemos trabajado con middlewares (en ASP.NET 4.x los módulos y handlers podían ejercer funciones similares, y más recientemente, en OWIN ya existía el mismo concepto), es ahora cuando debemos conocerlos bien si queremos llegar a comprender y dominar la nueva plataforma ASP.NET Core. Este este post vamos a profundizar un poco en el proceso de peticiones en ASP.NET Core, y veremos lo sencillo que resulta crear middlewares personalizados que participen en dicho proceso. Cómo se procesa una petición en ASP.NET CoreCuando una petición llega a una aplicación ASP.NET Core, es procesada por los middlewares[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/12/custom-middlewares-en-asp-net-core"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-12-15T08:05:00Z</dc:date>
  </entry>
  <entry>
    <title>Eliminar el encabezado "X-Powered-By" en ASP.NET Core</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2016/01/eliminar-el-encabezado-x-powered-by-en-asp-net-core" />
    <category term="desarrollo" />
    <category term="aspnetcore" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2016-01-24T13:15:05Z</updated>
    <published>2016-01-19T07:52:00Z</published>
    <content type="html">&lt;p&gt;Hace poco veíamos cómo crear un middleware capaz de realizar transformaciones simples en los encabezados de respuesta de nuestras aplicaciones ASP.NET Core. Nuestro componente, al que habíamos llamado HeaderTransformMiddleware, podíamos añadirlo al pipeline indicándole qué encabezados queríamos modificar y con qué valores (o nulo, si lo que queríamos era eliminar el encabezado). Por ejemplo, con el siguiente código añadíamos el encabezado "X-Author" y suprimíamos "Server": var transforms = new Dictionary&lt;string, string&gt;() {     ["X-Author"] = "José M. Aguilar",     ["Server"] = null }; app.UseHeaderTransform(transforms); Tras añadirlo al pipeline, la ejecución de una petición a una aplicación podríamos tener el siguiente resultado en los encabezados: HTTP/1.1 200 OK Content-Type: text/html;[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2016/01/eliminar-el-encabezado-x-powered-by-en-asp-net-core"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2016-01-19T07:52:00Z</dc:date>
  </entry>
  <entry>
    <title>Inyección de dependencias en ASP.NET 5 (actualizado)</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/10/inyeccion-de-dependencias-en-asp-net-5-actualizado" />
    <category term="desarrollo" />
    <category term="aspnet5" />
    <category term="aspnetmvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-11-23T08:02:03Z</updated>
    <published>2015-10-06T06:50:00Z</published>
    <content type="html">&lt;p&gt;Hace bastantes meses, allá por febrero, publiqué el post “ Inyección de dependencias en ASP.NET 5”, donde describía el sistema integrado de inyección de dependencias que se estaba construyendo en ASP.NET 5. Sin embargo, las cosas han cambiado un poco desde entonces, por lo que he pensado que sería buena idea reeditar el artículo y actualizarlo al momento actual, con la beta 8 de ASP.NET 5 a punto de publicarse. &lt;disclaimer&gt;Aunque el producto está cada vez más estable y completo, aún podrían cambiar cosas antes de la versión definitiva, incluso antes de tener la release candidate en la calle.&lt;/disclaimer&gt; Si no sabes aún lo que es inyección de dependencias, el resto del post te sonará a arameo antiguo. Quizás podrías echar previamente un vistazo a este otro, Desacoplando controladores ASP.NET[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/10/inyeccion-de-dependencias-en-asp-net-5-actualizado"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-10-06T06:50:00Z</dc:date>
  </entry>
  <entry>
    <title>El archivo _ViewImports en MVC 6</title>
    <link rel="alternate" href="http://www.blogstack.info/post/variablenotfound/2015/09/el-archivo-viewimports-en-mvc-6" />
    <category term="desarrollo" />
    <category term="novedades" />
    <category term="aspnet5" />
    <category term="aspnetmvc" />
    <author>
      <name>José M. Aguilar</name>
    </author>
    <updated>2015-09-25T19:00:25Z</updated>
    <published>2015-09-22T07:10:00Z</published>
    <content type="html">&lt;p&gt;Desde la llegada de Razor, hace ya bastante tiempo, usamos en MVC el archivo _ViewStart.cshtml de las carpetas de vistas de nuestra aplicación para introducir código de inicialización de éstas. Era un buen lugar para establecer propiedades como el Layout de forma genérica, sin tener que hacerlo en cada una de las vistas que se encontraran por debajo en el árbol de directorios en el que se definía. En MVC 6 se le ha unido un compañero llamado _ViewImports.cshtml, cuya finalidad y funcionamiento es parecido al tradicional ViewStart, porque se procesa antes de ejecutar una vista e igualmente afecta a todas las vistas que se encuentren por debajo de este archivo en el árbol de directorios, aunque aporta algunas diferencias bastante interesantes. Comentamos a continuación los aspectos más destacables.[...]&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.blogstack.info/post/variablenotfound/2015/09/el-archivo-viewimports-en-mvc-6"&gt;Leer artículo completo &amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</content>
    <dc:creator>José M. Aguilar</dc:creator>
    <dc:date>2015-09-22T07:10:00Z</dc:date>
  </entry>
</feed>

