<!DOCTYPE html><html data-debug-enabled="true" data-locale="es_ES" xmlns="http://www.w3.org/1999/xhtml"><head><meta content="Apache Tapestry Framework (version 5.4-beta-16)" name="generator"/><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta pagina="Post"/><title>Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria</title><!-- Resources --><link type="text/css" rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:400,700"/><link type="text/css" rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css"/><link title="Portada" type="application/atom+xml" rel="alternate" href="/feed.atom.xml"/><link type="image/png" rel="icon" href="/assets/images/favicon.png"/><meta content="Post" name="tapestry-page-name"/><link type="text/css" rel="stylesheet" href="/assets/tapestry5/bootstrap/css/bootstrap.css"/><link type="text/css" rel="stylesheet" href="/assets/tapestry5/tapestry.css"/><link type="text/css" rel="stylesheet" href="/assets/tapestry5/exception-frame.css"/><link type="text/css" rel="stylesheet" href="/assets/tapestry5/tapestry-console.css"/><link type="text/css" rel="stylesheet" href="/assets/tapestry5/tree.css"/><link type="text/css" rel="stylesheet" href="/assets/css/core.css"/></head><body data-page-initialized="false"><script type="text/javascript">document.write("<div class=\"pageloading-mask\"><div></div></div>");</script><header><div class="container-fluid"><div class="row"><div class="col-xs-12 col-sm-12 col-md-4"><h1><a class="blogstack" href="/"><span class="glyphicon glyphicon-th"></span> Blog <span class="stack">Stack</span></a></h1></div><div class="col-xs-12 col-sm-12 col-md-6"><nav role="navigation"><ul class="list-unstyled list-inline"><li><a class="header" href="/">Inicio</a></li><li><a class="header" href="/archive">Archivo</a></li><li><a class="header" href="/faq">Preguntas frecuentes</a></li><li><a class="header" href="/faq#aggregate">¿Quieres agregar tu bitácora?</a></li></ul></nav></div><div class="col-xs-6 col-sm-6 col-md-2"><a title="Fuente RSS, ¡suscríbete a BS!" alt="Fuente RSS" class="header" href="/feed.atom.xml"><span class="header icon entypo"></span></a><a title="Twitter, ¡sigue a BS!" alt="Twitter" class="header" href="http://twitter.com/blogstackinfo"><span class="header icon entypo-social"></span></a></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><h4>Un poco más que un agregador/planeta de bitácoras sobre programación, desarrollo, software libre, gnu/linux, tecnología, ...</h4></div></div></div><div class="container-fluid"><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><div class="imagen-cabecera"><div class="imagen"><div class="col-xs-12 col-sm-12 col-md-12" id="billboard"></div></div></div></div></div></div></header><div class="container-fluid content"><div class="row"><div class="col-xs-12 col-sm-12 col-md-8 content"><article itemtype="http://schema.org/BlogPosting" itemscope=""><a id="content"></a><header><h2><a href="/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii"><span itemprop="headline">Singletons en C++. Intentando que sean seguros en hilos (thread safety) II</span></a></h2></header><div class="row labels"><div class="col-md-12"><a class="label" href="/label/c"><img title="c" alt="c" src="/assets/images/labels/c.png"/></a><a class="label" href="/label/hardware"><img title="hardware" alt="hardware" src="/assets/images/labels/hardware.png"/></a></div></div><section class="post-data"><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><div><span>Escrito por <span itemprop="author">Gaspar Fernández</span> en la bitácora <a href="http://totaki.com/poesiabinaria/">Poesía binaria</a>, <a href="http://totaki.com/poesiabinaria/2014/04/singletons-en-c-thread-safety/"><span itemprop="sameAs">artículo original</span></a></span></div><div><span datetime="2014-04-22T08:50" itemprop="datePublished">Publicado el martes, 22 de abril de 2014 a las 08:50 UTC</span></div><div><span>
Etiquetado como
clases, instancia, concurrencia, c-11, objeto, procesador, creacion, hilos, exclusion, thread, simultaneo, mutex, arquitectura, <a href="/label/hardware"><span itemprop="articleSection">hardware</span></a>, unica, ejecucion, safe, cpu, algoritmos, volatile, c-c, cosas-que-damos-por-hechas, memoria, singleton, <a href="/label/c"><span itemprop="articleSection">c</span></a>, general</span></div></div></div></section><div class="text-justify post-content"><div class="share-this only-twitter"><span displayText="Tweet" class="st_twitter_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span></div><script src="http://w.sharethis.com/button/buttons.js" type="text/javascript"></script><script type="text/javascript">stLight.options({publisher: "ur-3b2014fd-82e-9968-7e00-5ee51fb88bb2", doNotHash: true, doNotCopy: true, hashAddressBar: false});</script><span itemprop="name"><p><a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3RvdGFraS5jb20vcG9lc2lhYmluYXJpYS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wNC90aHJlYWQuanBn"><img src="http://totaki.com/poesiabinaria/wp-content/uploads/2014/04/thread.jpg" alt="Singleton thread-safe" title="thread" width="500" height="375" /></a><a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3RvdGFraS5jb20vcG9lc2lhYmluYXJpYS8yMDE0LzA0L3NpbmdsZXRvbi1pbi1jcHAv">Ayer habl&aacute;bamos</a> de la creaci&oacute;n de un sigleton y de que nuestro ejemplo no era <em>“thread safe”</em>, vamos, que en un entorno con varios hilos de ejecuci&oacute;n cabe la posibilidad de que el comportamiento esperado no siempre se cumpla.</p> 
<p>Ah&iacute; encontr&aacute;bamos diferencias entre C++ (&lt;11) y C++11 ya que esta &uacute;ltima revisi&oacute;n incluye <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3RvdGFraS5jb20vcG9lc2lhYmluYXJpYS8yMDEzLzEwL2p1Z2FuZG8tY29uLXRocmVhZHMteS1tdXRleC1lbi1jMTEv">tratamiento de threads</a> y algunas cosas m&aacute;s que trataremos aqu&iacute;.</p> 
<p>Lo primero que podemos pensar, es que al traernos la instancia de nuestro singleton se crea una secci&oacute;n cr&iacute;tica, la cu&aacute;l podemos regular con un <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3RvdGFraS5jb20vcG9lc2lhYmluYXJpYS8yMDE0LzAyL2NvbmN1cnJlbmNpYS1jdWFuZG8tdmFyaW9zLWhpbG9zLXRocmVhZHMtcGVsZWFuLXBvci1lbC1hY2Nlc28tYS11bi1yZWN1cnNvLWVqZW1wbG9zLWVuLWMv">mutex</a>, provocando que <strong>siempre</strong> que vayamos a obtener una instancia de nuestro objeto pasemos por el sem&aacute;foro, y aunque dos threads quieran pelearse por ver qui&eacute;n crea antes el recurso, s&oacute;lo uno lo conseguir&aacute; finalmente.</p> 
<p>A partir de ahora, ya que antes de C++11 no tenemos mutex nativos (ya lo he dicho varias veces, bueno una m&aacute;s, a ver si mejora el SEO <img src="http://totaki.com/poesiabinaria/wp-includes/images/smilies/icon_smile.gif" alt=":)" /> ), la funci&oacute;n getInstance() quedar&aacute; as&iacute;:</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />6
      <br />7
      <br />8
      <br />9
      <br />10
      <br />11
      <br />12
      <br />13
      <br />14
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; static Singleton *getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; static pthread_mutex_t mutex;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_lock(&amp;mutex);
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; instance = new Singleton();
      <br /> &nbsp; &nbsp; else
      <br /> &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; &quot;Getting existing instance&quot;&lt;&lt;std::endl;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_unlock(&amp;mutex);
      <br /> 
      <br /> &nbsp; &nbsp; return instance;
      <br /> &nbsp; }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>Vemos como bloqueamos el mutex antes de hacer nada y desbloqueamos despu&eacute;s de construir el singleton, o despu&eacute;s de pasar la condici&oacute;n (instance == NULL), ahora, si varios threads entran a nuestra secci&oacute;n cr&iacute;tica, al no poder estar m&aacute;s de uno dentro de la misma, no pasa nada, porque cuando entre uno de los hilos y haga que <em>instance</em> tenga un determinado valor, el siguiente thread ver&aacute; que instance no es NULL, y <strong>no crear&aacute;</strong> una nueva instancia.</p> 
<p>Hasta aqu&iacute;, si probamos el c&oacute;digo creando muchos threads, no tendremos problemas (aunque hay algunas cosas m&aacute;s en tener en cuenta), porque los compiladores, hoy en d&iacute;a son muy listos y porque, en este caso, la biblioteca pthread est&aacute; bien implementada y no nos dar&aacute; guerra.</p> 
<p>Para probar el c&oacute;digo, podemos hacerlo con lo siguiente (no hay nada nuevo, pero vale para copiar y pegar):</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;height:300px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />6
      <br />7
      <br />8
      <br />9
      <br />10
      <br />11
      <br />12
      <br />13
      <br />14
      <br />15
      <br />16
      <br />17
      <br />18
      <br />19
      <br />20
      <br />21
      <br />22
      <br />23
      <br />24
      <br />25
      <br />26
      <br />27
      <br />28
      <br />29
      <br />30
      <br />31
      <br />32
      <br />33
      <br />34
      <br />35
      <br />36
      <br />37
      <br />38
      <br />39
      <br />40
      <br />41
      <br />42
      <br />43
      <br />44
      <br />45
      <br />46
      <br />47
      <br />48
      <br />49
      <br />50
      <br />51
      <br />52
      <br />53
      <br />54
      <br />55
      <br />56
      <br />57
      <br />58
      <br />59
      <br />60
      <br />61
      <br />62
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      #include &lt;iostream&gt;
      <br /> #include &lt;pthread.h&gt;
      <br /> #include &lt;cstdlib&gt;
      <br /> #include &lt;unistd.h&gt;
      <br /> 
      <br /> using namespace std;
      <br /> 
      <br /> class Singleton
      <br /> {
      <br /> public:
      <br /> &nbsp; static Singleton *getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; static pthread_mutex_t mutex;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_lock(&amp;mutex);
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; instance = new Singleton();
      <br /> &nbsp; &nbsp; else
      <br /> &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; &quot;Getting existing instance&quot;&lt;&lt;std::endl;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_unlock(&amp;mutex);
      <br /> 
      <br /> &nbsp; &nbsp; return instance;
      <br /> &nbsp; }
      <br /> 
      <br /> protected:
      <br /> &nbsp; Singleton()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; std::cout &lt;&lt; &quot;Creating singleton&quot; &lt;&lt; std::endl;
      <br /> &nbsp; }
      <br /> 
      <br /> &nbsp; virtual ~Singleton()
      <br /> &nbsp; {
      <br /> &nbsp; }
      <br /> 
      <br /> &nbsp; Singleton(Singleton const&amp;);&nbsp; 
      <br /> &nbsp; Singleton&amp; operator=(Singleton const&amp;);
      <br /> 
      <br /> private:
      <br /> &nbsp; static Singleton *instance;
      <br /> &nbsp; int x;
      <br /> };
      <br /> 
      <br /> Singleton* Singleton::instance=NULL;
      <br /> 
      <br /> void *task (void*)
      <br /> {
      <br /> &nbsp; Singleton *s = Singleton::getInstance();
      <br /> &nbsp; cout &lt;&lt; &quot;Thread con instancia&quot;&lt;&lt;endl;
      <br /> }
      <br /> 
      <br /> int main()
      <br /> {
      <br /> &nbsp; for (unsigned i=0; i&lt;100; ++i)
      <br /> &nbsp; &nbsp; {
      <br /> &nbsp; &nbsp; &nbsp; pthread_t thread;
      <br /> &nbsp; &nbsp; &nbsp; int rc = pthread_create(&amp;thread, NULL, task, NULL);
      <br /> &nbsp; &nbsp; }
      <br /> 
      <br /> &nbsp; pthread_exit(NULL);
      <br /> &nbsp; return 0;
      <br /> }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<h2>Aumentando el rendimiento del Singleton</h2> 
<p>Una primera optimizaci&oacute;n que podemos hacer es implementar un <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtY2hlY2tlZF9sb2NraW5n">DCLP</a> (Double-checked locking pattern o patr&oacute;n de bloqueo con doble comprobaci&oacute;n), el objetivo de esto es que, siempre que hacemos getInstance() pasamos por el mutex, y esto consume ciclos de CPU, pero una vez que ya est&eacute; creada la instancia, no har&aacute; falta entrar en el mutex m&aacute;s veces, puesto que <em>instance</em> ya tiene un valor. El caso es que cuando ya tengamos la instancia de nuestro singleton, no tenemos por qu&eacute; bloquear / comprobar / desbloquear, por lo tanto, podemos introducir una comprobaci&oacute;n antes de bloquear (en el peor de los casos, gastaremos un acceso a memoria y una comprobaci&oacute;n de una variable m&aacute;s), pero en el mejor de los casos (que se producir&aacute; normalmente muchas m&aacute;s veces), s&oacute;lo gastaremos esa comprobaci&oacute;n y retornaremos antes de getInstance().</p> 
<p>Al final, dejamos la funci&oacute;n as&iacute;:</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />6
      <br />7
      <br />8
      <br />9
      <br />10
      <br />11
      <br />12
      <br />13
      <br />14
      <br />15
      <br />16
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; static Singleton *getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; {
      <br /> &nbsp; &nbsp; static pthread_mutex_t mutex;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_lock(&amp;mutex);
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; instance = new Singleton();
      <br /> &nbsp; &nbsp; else
      <br /> &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; &quot;Getting existing instance&quot;&lt;&lt;std::endl;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_unlock(&amp;mutex);
      <br /> &nbsp; &nbsp; &nbsp; }
      <br /> &nbsp; &nbsp; return instance;
      <br /> &nbsp; }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>Otra medida que podemos tomar para aumentar el rendimiento es, en el caso de necesitar la instancia para muchas acciones, hacer una copia de la misma, es decir, copiarnos el puntero en una variable local y realizar las acciones sobre &eacute;l, en lugar de hacer muchas llamadas seguidas a getInstance().</p> 
<h2>Problemas que pueden aparecer</h2> 
<p>Podemos encontrar otro gran problema en la optimizaci&oacute;n de los compiladores, y de las CPUs modernas, y es que <strong>nadie nos garantiza</strong> que en</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; &nbsp; &nbsp; instance = new Singleton();
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>primero se asigne el valor de instance y luego se llame al constructor, ni siquiera que luego se desbloquee el mutex. Tambi&eacute;n es cierto que la biblioteca pthread funciona muy bien, y a&iacute;sla nuestro c&oacute;digo (pone memory barriers de pormedio), y no vamos a tener problema con ella, siempre que trabajemos en un unix con esta biblioteca (usando funciones pthread_*). Pero como bibliotecas hay muchas, no est&aacute; de m&aacute;s advertir sobre esto. Es m&aacute;s, a veces podemos pillar que alg&uacute;n thread, pasa del primer <em>if ( instance == NULL )</em> y quiere cargar el segundo, pero el sem&aacute;foro lo ha parado.</p> 
<p>Otro problema es que, el valor de las variables cambia sin previo aviso, es decir, para un thread, la variable instance podr&aacute; tener un valor, y sin que ocurra nada en la ejecuci&oacute;n de ese thread cambie de valor (claro, porque otro thread lo ha cambiado sin que el actual se d&eacute; cuenta). Esto no es nada nuevo, pero los compiladores optimizan mucho el c&oacute;digo m&aacute;quina resultante, tanto, que si antes no se aseguraba el orden de las sentencias, ahora tampoco se asegura que lo que en realidad cambie sea la variable que hemos dicho, o en realidad se hace un cambio en un registro que se volcar&aacute; m&aacute;s tarde a memoria, o si no se hace uso de esa memoria, tal vez nunca llegue.</p> 
<p>Todo eso est&aacute; muy bien, al final lo que conseguimos es que nuestro programa se ejecute m&aacute;s r&aacute;pido, haciendo que el compilador <strong>emplee trucos</strong>. Por otro lado, las optimizaciones se pueden desactivar, aunque nosotros queremos que los programas aprovechen al m&aacute;ximo la CPU donde ejecutamos, por lo que est&aacute; feo no optimizar el ejecutable final. Lo que podemos hacer es obligar a una variable a leer y escribir siempre en memoria, y para ello utilizaremos la palabra clave <strong>volatile</strong>. <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Wb2xhdGlsZV92YXJpYWJsZQ==">volatile</a>, en principio se utiliz&oacute; para dispositivos hardware mapeados en memoria, para acceder a estos dispositivos utiliz&aacute;bamos direcciones de memoria, y por tanto, los valores de dichas direcciones, <strong>pod&iacute;an variar por la cara</strong>, sin que el programa controlara dichas variaciones, por tanto forzando el acceso a memoria, siempre que realicemos una operaci&oacute;n sobre dicha variable leeremos de nuevo el valor (dejando aparte optimizaciones que no se aplicar&iacute;an en este caso). Volviendo al tema del multi-hilo, al escribir los valores directamente en su posici&oacute;n de memoria, otro hilo podr&aacute; hacer una lectura de la misma y ver que, en efecto, se ha modificado.</p> 
<p>Por lo tanto, si creamos instance como volatile, estar&iacute;a un poco mejor, aunque tenemos que saber tambi&eacute;n que los compiladores m&aacute;s modernos no tendr&aacute;n este problema y que en <em>C++11, volatile ha quedado reservado exclusivamente a acceso hardware</em>, por lo que no debemos utilizarlo en esta &uacute;ltima revisi&oacute;n del lenguaje. Aunque lo dicho, para versiones anteriores, obtendremos mejores resultados.</p> 
<h2>C++11</h2> 
<p>C++11 no tiene problema, y en la inicializaci&oacute;n de la variable asegura la seguridad entre hilos de ejecuci&oacute;n, por lo que no tenemos que complicarnos la vida (siempre y cuando el compilador sea 100% compatible con las especificaciones):</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; static Singleton *getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; static Singleton* s = new Singleton();
      <br /> &nbsp; &nbsp; return s;
      <br /> &nbsp; }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>En el caso en el que nuestro compilador no cumpla, tengamos duda, o no podamos determinar d&oacute;nde compilamos, es seguro utilizar std::call_once y std::unique_ptr para almacenar el puntero a la instancia actual, dejando nuestro Singleton as&iacute; (fuente <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3d3dy5udW9uc29mdC5jb20vYmxvZy8yMDEyLzEwLzIxL2ltcGxlbWVudGluZy1hLXRocmVhZC1zYWZlLXNpbmdsZXRvbi13aXRoLWMxMS8=">Marc Gregoires</a>):</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;height:300px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />6
      <br />7
      <br />8
      <br />9
      <br />10
      <br />11
      <br />12
      <br />13
      <br />14
      <br />15
      <br />16
      <br />17
      <br />18
      <br />19
      <br />20
      <br />21
      <br />22
      <br />23
      <br />24
      <br />25
      <br />26
      <br />27
      <br />28
      <br />29
      <br />30
      <br />31
      <br />32
      <br />33
      <br />34
      <br />35
      <br />36
      <br />37
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      #include &lt;iostream&gt;
      <br /> #include &lt;cstdlib&gt;
      <br /> #include &lt;unistd.h&gt;
      <br /> #include &lt;mutex&gt;
      <br /> #include &lt;memory&gt;
      <br /> 
      <br /> class Singleton
      <br /> {
      <br /> public:
      <br /> &nbsp; static Singleton *getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; std::call_once(m_onceFlag,
      <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[] {
      <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m_instance.reset(new Singleton);
      <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});
      <br /> &nbsp; &nbsp; return m_instance.get();
      <br /> &nbsp; }
      <br /> 
      <br /> &nbsp; virtual ~Singleton()
      <br /> &nbsp; {
      <br /> &nbsp; }
      <br /> 
      <br /> protected:
      <br /> &nbsp; Singleton()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; std::cout &lt;&lt; &quot;Creating singleton&quot; &lt;&lt; std::endl;
      <br /> &nbsp; }
      <br /> 
      <br /> &nbsp; Singleton(Singleton const&amp;);&nbsp; 
      <br /> &nbsp; Singleton&amp; operator=(Singleton const&amp;);
      <br /> 
      <br /> private:
      <br /> &nbsp; static std::unique_ptr&lt;Singleton&gt; m_instance;
      <br /> &nbsp; static std::once_flag m_onceFlag;
      <br /> 
      <br /> &nbsp; int x;
      <br /> };
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<h2>Una &uacute;ltima nota</h2> 
<p>Si en lugar de devolver un puntero a nuestra instancia (porque como nos hagan un delete se puede liar, aunque si tenemos el destructor privado dar&aacute; un fallo de compilaci&oacute;n), queremos devolver la referencia a la instancia, tambi&eacute;n podemos, debemos hacer algo como:</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; static Singleton &amp;getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; static s = new Singleton();
      <br /> &nbsp; &nbsp; return s;
      <br /> &nbsp; }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>para C++11, o</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />2
      <br />3
      <br />4
      <br />5
      <br />6
      <br />7
      <br />8
      <br />9
      <br />10
      <br />11
      <br />12
      <br />13
      <br />14
      <br />15
      <br />16
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; static Singleton &amp;getInstance()
      <br /> &nbsp; {
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; {
      <br /> &nbsp; &nbsp; static pthread_mutex_t mutex;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_lock(&amp;mutex);
      <br /> &nbsp; &nbsp; if (instance == NULL)
      <br /> &nbsp; &nbsp; &nbsp; instance = new Singleton();
      <br /> &nbsp; &nbsp; else
      <br /> &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; &quot;Getting existing instance&quot;&lt;&lt;std::endl;
      <br /> 
      <br /> &nbsp; &nbsp; pthread_mutex_unlock(&amp;mutex);
      <br /> &nbsp; &nbsp; &nbsp; }
      <br /> &nbsp; &nbsp; return *instance;
      <br /> &nbsp; }
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>para versiones anteriores. Como veis, cambiamos el Singleton* que devuelve getInstance() por Singleton&amp; y en lugar de devolver instance, devolvemos *instance, por lo que seguimos almacenando el puntero internamente, pero devolvemos una referencia a nuestro objeto. Para acceder a dicho Singleton debemos tener cuidado y hacerlo de la siguiente manera:</p> 
<div style="overflow:auto;white-space:nowrap;border:1px solid #9F9F9F;width:435px;">
 <table>
  <tbody>
   <tr>
    <td>
     <div>
      1
      <br />
     </div></td>
    <td>
     <div style="padding:5px;font:normal 12px/1.4em Monaco, Lucida Console, monospace;white-space:nowrap">
      &nbsp; Singleton&amp; sing = Singleton::getInstance();
     </div></td>
   </tr>
  </tbody>
 </table>
</div> 
<p>as&iacute; evitamos destrucciones inesperadas.</p> 
<h2>Para leer…</h2> 
<p><a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3d3dy5hcmlzdGVpYS5jb20vUGFwZXJzL0RESl9KdWxfQXVnXzIwMDRfcmV2aXNlZC5wZGY=">C++ and the Perils of Double-Checked Locking</a><br /> <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1vcnlfYmFycmllcg==">Memory Barrier (Wikipedia)</a><br /> <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3BsYWdhdHV4LmVzLzIwMDgvMDkvYy1wYXRyb24tZGUtZGlzZW5vLXNpbmdsZXRvbi8=">La Plaga Tux</a><br /> <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cDovL3ByZXNoaW5nLmNvbS8yMDEzMDkzMC9kb3VibGUtY2hlY2tlZC1sb2NraW5nLWlzLWZpeGVkLWluLWNwcDExLw==">Double-Checked Locking is fixed in C++11</a></p> 
<p>Foto: <a href="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?url=aHR0cHM6Ly93d3cuZmxpY2tyLmNvbS9waG90b3MvYW1hZ2lsbC84NzU1OTk2OC9pbi9waG90b2xpc3QtOEpMd0MtMkRnOExQLTZkaTZWUS1rdm1jV3otZTFQU2drLWZ4RUFuSC04NzNEM3QtNWtSWGtRLTdYNm5teC12RzJ6Uy03MUwxQlkta3ZtaVNULWZ6YTlNOS1hb0dlYlUtN1ZKeGJuLXJVeUcyLUhKUGhCLWZ4VVE0My1meEV5ZDgtZnhFd3BULTcxRlphdC02NjJWOUMtZnlVUjJQLWZ5VVBSei1meEV4R1otZnhFeEd0LWZ4RUM1Ri1meEVDNUgtZnphOFM5LWZ4VVE0cS1mVUpOWWUtYXpOWlZMLWRObks1by1nSGcxVVYtZ0hmUEYxLWZ5VjE0ei1meVYxNHYtZnlVUVdYLWZ6YTlkdS1oazdHRWktZnhVUjVtLWZ4RXZreC00SlRONjUtZnhVVW5zLWZ5VVBVUC1meEV5WmMtZnhFeVl4LWZ4VVBSSi1lQzFGSzktZnhFQXNC">Andrew Magill</a> (Flickr CC-by)</p> 
<div>
 <iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Ftotaki.com%2Fpoesiabinaria%2F2014%2F04%2Fsingletons-en-c-thread-safety%2F&amp;layout=standard&amp;show_faces=true&amp;width=500&amp;action=like&amp;font=segoe+ui&amp;colorscheme=light&amp;height=80" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:500px; height:80px;"></iframe>
</div> 
<img src="http://totaki.com/poesiabinaria/wp-content/plugins/wordpress-feed-statistics/feed-statistics.php?view=1&amp;post_id=2274" width="1" height="1" style="display: none;" />
<p>La entrada <a href="http://totaki.com/poesiabinaria/2014/04/singletons-en-c-thread-safety/">Singletons en C++. Intentando que sean seguros en hilos (thread safety) II</a> aparece primero en <a href="http://totaki.com/poesiabinaria">Poes&iacute;a Binaria</a>.</p></span></div><section><a id="share"></a><h1>Compartir</h1><div class="share-this"><span displayText="Tweet" class="st_twitter_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span><span displayText="Facebook" class="st_facebook_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span><span displayText="Google +" class="st_googleplus_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span><span displayText="LinkedIn" class="st_linkedin_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span><span displayText="Meneame" class="st_meneame_vcount" st_url="http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii" st_title="Singletons en C++. Intentando que sean seguros en hilos (thread safety) II | Poesía binaria"></span></div><script src="http://w.sharethis.com/button/buttons.js" type="text/javascript"></script><script type="text/javascript">stLight.options({publisher: "ur-3b2014fd-82e-9968-7e00-5ee51fb88bb2", doNotHash: true, doNotCopy: true, hashAddressBar: false});</script><div id="widget"></div></section><hr/></article></div><div class="col-xs-12 col-sm-12 col-md-4"><aside><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><section><h3>¡Suscríbete!</h3><ul class="list-unstyled"><li><a href="/label/hardware/feed.atom.xml"><span class="fa fa-rss"></span> Fuente de la etiqueta hardware</a></li><li><a href="/label/c/feed.atom.xml"><span class="fa fa-rss"></span> Fuente de la etiqueta c</a></li></ul></section></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><div id="bigRectangle"></div></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><section><h3>Redes sociales</h3><p>¿Te gusta Blog Stack? ¡Compártelo!</p><div class="social-networks"><!-- Facebook --><div class="social-network"><div data-share="true" data-show-faces="false" data-action="like" data-width="310" data-layout="box_count" data-href="http://www.blogstack.info/" class="fb-like"></div></div><!-- Google+ --><div class="social-network"><div class="g-plusone" data-href="http://www.blogstack.info/" data-size="tall"></div></div></div></section></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><section id="lastPosts"></section></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><div id="bigSkycraper"></div></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><section id="lastPosts_0"></section></div></div></aside></div></div></div><footer><div class="container-fluid"><div class="row"><div class="col-xs-12 col-sm-12 col-md-12"><div class="footer"><a href="/">Blog Stack</a> por <a href="https://twitter.com/picodotdev/">pico.dev</a> está publicado bajo la licencia de software libre <a href="http://www.gnu.org/licenses/agpl-3.0.html">GNU Affero General Public</a> en <a href="https://github.com/picodotdev/blog-stack">GitHub <span class="entypo-social"></span></a>.<br/>
El contenido agregado conserva la licencia de su bitácora.<br/>
«Powered by» <a href="https://github.com/picodotdev/blogstack">Blog Stack</a>, <a href="http://tapestry.apache.org/">Apache Tapestry</a>, <a href="https://www.openshift.com/">OpenShift</a>, <a href="https://pages.github.com/">GitHub Pages</a>, <a href="http://www.oracle.com/es/technologies/java/overview/index.html">Java</a> y más software libre o de código abierto, inspirado en <a href="http://octopress.org/">Octopress</a>.<br/><span class="copyleft">©</span> pico.dev 2015
</div></div></div></div></footer><div id="fb-root"></div><script type="text/javascript">var require = {
  "waitSeconds" : 300,
  "shim" : {
    "t5/core/typeahead" : [
      "jquery"
    ],
    "bootstrap/affix" : [
      "bootstrap/transition"
    ],
    "bootstrap/alert" : [
      "bootstrap/transition"
    ],
    "bootstrap/modal" : [
      "bootstrap/transition"
    ],
    "bootstrap/tab" : [
      "bootstrap/transition"
    ],
    "bootstrap/transition" : [
      "jquery"
    ],
    "bootstrap/button" : [
      "bootstrap/transition"
    ],
    "bootstrap/scrollspy" : [
      "bootstrap/transition"
    ],
    "bootstrap/collapse" : [
      "bootstrap/transition"
    ],
    "bootstrap/dropdown" : [
      "bootstrap/transition"
    ],
    "bootstrap/tooltip" : [
      "bootstrap/transition"
    ],
    "bootstrap/carousel" : [
      "bootstrap/transition"
    ],
    "bootstrap/popover" : [
      "bootstrap/tooltip"
    ]
  },
  "baseUrl" : "/modules"
};
</script><script src="/assets/tapestry5/require.js" type="text/javascript"></script><script src="/assets/tapestry5/underscore-1.5.2.js" type="text/javascript"></script><script src="/assets/tapestry5/scriptaculous_1_9_0/prototype.js" type="text/javascript"></script><script src="/assets/tapestry5/scriptaculous_1_9_0/scriptaculous.js" type="text/javascript"></script><script src="/assets/tapestry5/scriptaculous_1_9_0/effects.js" type="text/javascript"></script><script src="/assets/tapestry5/t53-compatibility.js" type="text/javascript"></script><script src="/assets/tapestry5/jquery.js" type="text/javascript"></script><script src="/assets/tapestry5/jquery-noconflict.js" type="text/javascript"></script><script type="text/javascript">require(["t5/core/pageinit"], function(pi) { pi([], [
  "app/analytics",
  [
    "app/karmacracy:init",
    {
      "selector" : "#widget",
      "id" : 417,
      "url" : "http://www.blogstack.info/post/poesiabinaria/2014/04/singletons-en-c-intentando-que-sean-seguros-en-hilos-thread-safety-ii"
    }
  ],
  "app/facebook",
  "app/googleplus",
  [
    "app/lastPosts:init",
    {
      "id" : "lastPosts",
      "source" : "poesiabinaria",
      "name" : "Poesía binaria"
    }
  ],
  [
    "app/lastPosts:init",
    {
      "id" : "lastPosts_0",
      "source" : "blogstack",
      "name" : "Blog Stack"
    }
  ],
  [
    "app/adsensem:init",
    {
      "blogstack" : {
        "adClient" : "ca-pub-3533636310991304",
        "adSlot" : "1397019380"
      }
    }
  ]
]); });</script></body></html>